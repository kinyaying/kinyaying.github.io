<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>5分钟上手开发浏览器插件——油猴脚手架wokoo(使用篇)</title>
    <url>/2021/02/12/5%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%E5%BC%80%E5%8F%91%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E2%80%94%E2%80%94%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%89%8B%E6%9E%B6wokoo(%E4%BD%BF%E7%94%A8%E7%AF%87)/</url>
    <content><![CDATA[<h2 id="油猴插件是什么？"><a href="#油猴插件是什么？" class="headerlink" title="油猴插件是什么？"></a>油猴插件是什么？</h2><p>油猴插件(Tampermonkey) 是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Edge, Safari等多个浏览器。油猴脚本本质上是在网页上插入一段 JavaScript(JS) 代码，开发者在代码中编写内容，开发插件。此外，它还提供Userscript Header和Application Programming Interface给开发者，用来实现原生 JS 无法实现的功能。</p>
<span id="more"></span>
<p>油猴插件的开发文档请看这里 👉 [<a href="https://www.tampermonkey.net/documentation.php?version=4.6&ext=dhdg">油猴插件开发文档</a>]</p>
<h2 id="为什么要开发wokoo脚手架"><a href="#为什么要开发wokoo脚手架" class="headerlink" title="为什么要开发wokoo脚手架"></a>为什么要开发wokoo脚手架</h2><p>油猴插件的基本原理是支持用户使用js编写脚本代码，再在网页的环境上下文运行。</p>
<p>在油猴插件生成的基础项目中，可以看到什么都没有配置，它只支持原生js开发。这对于我们熟悉vue或react的FEer来说影响效率。我们需要自己搭建一个基础的项目工程，进行开发。还要配置油猴脚本内容，确保油猴插件引入了我们开发的js代码，比较麻烦。而wokoo则是为了解决这个问题。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f5eca70aa145feb6ca36b90c04665d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>先介绍下wokoo脚手架的成果：</p>
<p><a href="https://github.com/kinyaying/wokoo">wokoo脚手架github仓库</a></p>
<p>安装油猴插件：<a href="https://chrome.google.com/webstore/detail/tampermonkey-beta/gcalenpjmijncebpfijmoaglllgpjagf?hl=zh-CN">油猴插件安装地址</a></p>
<p>安装demo插件: <a href="https://greasyfork.org/zh-CN/scripts/420327-wokoo-demo">wokoo-demo</a> （详细安装过程可查看 ➡️ <a href="https://github.com/kinyaying/wokoo/tree/master/example/wokoo-demo">wokoo-demo/readme</a>）</p>
<p>安装完成后的效果如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e978d446a66435b9cf1f9b30eee979d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<h2 id="wokoo是什么"><a href="#wokoo是什么" class="headerlink" title="wokoo是什么"></a>wokoo是什么</h2><p>一款油猴插件的脚手架。如果直接开发油猴插件，开发者需要费时搭建vue或react基础项目，还需要对油猴脚本区域做对应的配置，开发体验差。</p>
<p>wokoo可以一键式生成基础项目，并且提供基础Tampermonkey配置。</p>
<p>主要提供的功能有：</p>
<ul>
<li>命令行式创建脚手架初始项目</li>
<li>根据用户选择，生成vue、react的基本项目</li>
<li>tampermonkey.txt 文件中提供Tampermonkey配置</li>
</ul>
<h2 id="项目设计图"><a href="#项目设计图" class="headerlink" title="项目设计图"></a>项目设计图</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf77f0701b274c7483a0d6aaba207640~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>wokoo脚手架的设计参考了<a href="https://github.com/facebook/create-react-app">create-react-app</a>，我也曾经写过一篇分析cra源码的文章，感兴趣的同学可以阅读这篇👉<a href="https://juejin.cn/post/6916531902773985294">create-react-app核心源码解读</a>。</p>
<p>wokoo主要使用lerna进行包管理，在packages里维护了两个模块：wokoo-scripts 和 wokoo-template。</p>
<p><strong>wokoo-scripts</strong>：</p>
<p>分析终端用户输入的命令行，根据用户输入的选项生成对应的初始化项目</p>
<p><strong>wokoo-template</strong>：项目模板</p>
<ul>
<li>分为vue和react</li>
<li>支持基础的webpack配置</li>
<li>tampermonkey.txt 文件中是油猴编辑器内容，用户不必自己编写油猴脚本的配置。并且此处做了优化，在tampermonkey.txt中使用动态引入js脚本的方案，而不是@require引入js文件方式，解决开发时静态资源缓存问题。</li>
</ul>
<p>wokoo工作流如下图👇：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/666e725ea331445387a7f8ac8f76b106~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<h2 id="wokoo脚手架使用"><a href="#wokoo脚手架使用" class="headerlink" title="wokoo脚手架使用"></a>wokoo脚手架使用</h2><ol>
<li>安装 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i wokoo -g</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 创建my-plugin项目</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wokoo my-plugin</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>选择框架：控制台出现提示 ➡️ which template do you prefer?</li>
</ol>
<p>[ ] vue</p>
<p>[ ] react</p>
<ol start="4">
<li><p> 选择完毕后自动初始化项目</p>
</li>
<li><p>cd my-plugin 能够看到生成的原始项目</p>
</li>
</ol>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md </span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── public                    静态文件</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── icon.jpg</span><br><span class="line">│   └── index.html            html文件</span><br><span class="line">├── src</span><br><span class="line">│   ├── app.less</span><br><span class="line">│   ├── app.js</span><br><span class="line">│   └── index.js             项目入口</span><br><span class="line">├── tampermonkey.txt         油猴脚本入口文件</span><br><span class="line">├── webpack.config.base.js</span><br><span class="line">└── webpack.config.js        webpack 配置</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此处展示的是react项目的目录结构，vue项目的结构类似，不再展示。</p>
<p>其中<code>tampermonkey.txt</code>文件内是油猴脚本配置，需要将里面的内容复制到Tampermonkey编辑器里。</p>
<h2 id="开发-amp-调试"><a href="#开发-amp-调试" class="headerlink" title="开发&amp;调试"></a>开发&amp;调试</h2><ol>
<li>启动 </li>
</ol>
<p>进入项目目录后，在命令行中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm start</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>打开浏览器，输入<code>localhost:8080</code>，查看页面展示是否正常。</p>
</li>
<li><p>打开油猴插件编辑界面，将 <code>tampermonkey.txt</code> 里的内容复制到编辑框中，保存。（此步骤默认你已经安装了油猴插件，没安装的话就安装下 👉<a href="https://chrome.google.com/webstore/detail/tampermonkey-beta/gcalenpjmijncebpfijmoaglllgpjagf?hl=zh-CN">油猴插件安装地址</a>）</p>
</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05cb9892e1bd42f4bd12e36f39e185a2~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3160f3a1c95147ed8fd8d598b9b1966d~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p><code>tampermonkey.txt</code> 中的js逻辑是给html拼上script标签来获取外部js文件，在开发过程中不要担心缓存问题，开发完代码后能直接在浏览器看到最新的效果。</p>
<ol start="4">
<li>打开任意一个网页，比如<a href="http://www.baidu.com/">www.baidu.com</a></li>
</ol>
<ul>
<li>查看油猴 icon 是否有一个 1 的数字标志，如果有说明油猴脚本已经成功激活</li>
<li>网页的右上角会出现一只猴子，说明代码已经跑通</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4304f711784a440db86d03f237f0b81a~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<ol start="5">
<li>接下来可以修改业务代码进行自定义的插件开发啦~ 🎊🎊</li>
</ol>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="发布插件到油猴市场"><a href="#发布插件到油猴市场" class="headerlink" title="发布插件到油猴市场"></a>发布插件到油猴市场</h2><p>发布油猴市场的优点是不用审核，即发即用，非常方便。</p>
<ol>
<li>将<code>/dist/app.bundle.js</code> 文件部署到 cdn 上，获取到对应 url。</li>
</ol>
<p>注意：</p>
<ul>
<li><p>js文件可放到 github 上，如果托管到 github 上最好做 cdn 加速</p>
</li>
<li><p>如果没有cdn服务器可跳过此步骤，在步骤4直接将app.bundle.js复制到油猴脚本编辑器中</p>
</li>
</ul>
<ol start="2">
<li><p>登录<a href="https://greasyfork.org/">油猴市场</a>，谷歌账号或 github 账号都可使用。</p>
</li>
<li><p>点击账号名称，再点击「发布你编写的脚本」<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abcdfbc992fb4fd69a2178ca94876071~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb025dd64bc643a48858a875f9c70fdc~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
</li>
<li><p>进入编辑页，将 <code>tampermonkey.txt</code> 里的内容复制到编辑框中</p>
</li>
</ol>
<p>注意：</p>
<ul>
<li><p>步骤1中如果托管了cdn，需要将代码中的<code>localhost:8080</code>网址替换成静态资源 url</p>
</li>
<li><p>步骤1中没有托管cdn，则将<code>/dist/app.bundle.js</code>文件里的内容复制到下图红框位置</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7aaced8f163842af9e165b7a98388198~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
</li>
</ul>
<ol start="5">
<li>点击 「发布脚本」即可</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6916531902773985294">create-react-app核心源码解读</a></p>
<p><a href="https://sleazyfork.org/zh-CN/scripts?page=1">油猴市场</a> </p>
<p><a href="https://www.tampermonkey.net/documentation.php?version=4.6&ext=dhdg">油猴插件开发文档</a></p>
<p>——</p>
<p>未来wokoo脚手架也会持续更新，如果有相关问题或建议可以在github上提issue或者联系我 email: <a href="mailto:kinyaying@gamil.com">kinyaying@gamil.com</a>。</p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】五大原则写出优雅易维护的vue代码</title>
    <url>/2021/02/09/%5B%E8%AF%91%5D5%E5%A4%A7%E5%8E%9F%E5%88%99%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E6%98%93%E7%BB%B4%E6%8A%A4%E7%9A%84vue%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>本文翻译自：<a href="https://betterprogramming.pub/5-principles-for-writing-clean-and-maintainable-vue-js-code-35dfcf5ef08c">https://betterprogramming.pub/5-principles-for-writing-clean-and-maintainable-vue-js-code-35dfcf5ef08c</a></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/680f207807a24fb2a3865302e31a4a3a~tplv-k3u1fbpfcp-watermark.image"></p>
<p>在编码过程中，让编写的代码清晰易懂是一件重要的事情。清晰的代码就像一瓶好酒，没法立刻显示出优势，但是随着时间的推移仍能让读它的人觉得很好理解，这便是最大的优势。</p>
<p>而有些代码写的低内聚，逻辑混乱，就像意大利面条一样混乱。你在当时能够理清混乱的逻辑，但是等过 3 个月，5 个月或者 20 个月后再去看这段代码，情况就会很糟糕。</p>
<p>作为一个程序员，我在编程（包括 vue 项目）时会坚持一个重要原则，我把它称为 DRY 原则。</p>
<p>DRY 是<em>don’t repeat yourself</em>的缩写，也就是说要减少编程中的重复逻辑。</p>
<span id="more"></span>

<p>坚持 DRY 原则的原因是当编写同一段逻辑两次以上，会产生更加复杂的情况。举个简单的例子：</p>
<p>你在你的代码中复制了一段代码到不同地方，当你或者其他程序员想重构这段逻辑时你们该怎么做？你们不得不重构两个地方。这又会导致多个新问题：</p>
<ul>
<li>你只改了一个地方，忘记改另一个</li>
<li>你修改了这段代码，并改动了每个被复制过的地方。但是你发现一共改了 5 处。</li>
<li>你已经 5 个月没写这个项目了，然后突然要回来改这段代码。你还记得这段代码被复制到多个地方吗？</li>
</ul>
<p>如果你编写的代码足够清晰就能够避免很多问题，同时节约大量时间。短期内不一定很有效果，但是长期看来逻辑清晰的代码能够提高编码效率。</p>
<h1 id="使用-Mixins"><a href="#使用-Mixins" class="headerlink" title="使用 Mixins"></a>使用 Mixins</h1><p>在 Vue 中复用方法，数据属性，计算属性等的主要方式是 Mixins。</p>
<p>如果你在不同组件间有可复用的逻辑，最好把这段逻辑提取出来，然后通过 mixins 来共享。</p>
<p>假设你的项目有多个路由，并且使用 vue-router 将每个路由与对应的组件联系起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- App.vue</span><br><span class="line">-- Home.vue</span><br><span class="line">-- Analytics.vue</span><br><span class="line">-- Reports.vue</span><br></pre></td></tr></table></figure>

<p>假设现在有一个产品导览组件，你希望在所有页面都拥有这个组件。</p>
<p>如果你不使用 mixins，但是希望产品导览出现在所有页面上，则需要将相同的代码复制到每个页面组件的<code>mounted</code>，还需要给每个页面组件添加<code>startProductTour</code>方法。 我在此处编写了 Home.vue 示例，然后你需要往 Analytics.vue 和 Reports.vue 里复制代码。</p>
<p><strong>Home.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123; mounted() &#123; this.startProductTour(); &#125;. methods: &#123;</span><br><span class="line">startProductTour() &#123; &#x2F;&#x2F; start product tour actions here &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>但是如果将这段逻辑抽离出来，并使用 mixin…</p>
<p><code>**ProductTour**</code> <strong>mixin</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.startProductTour();</span><br><span class="line">  &#125;.</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">startProductTour</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// start product tour actions here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…只要一行代码，您就可以在所有组件中使用它。 而且，如果你更改代码，也只需更新一次 mixin，而无需编辑多个文件。</p>
<p><strong>Home.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ProductTourMixin from &#39;..&#x2F;mixins&#x2F;ProductTourMixin&#39;; export default &#123;</span><br><span class="line">mixins: [ProductTourMixin] &#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，您的新项目结构将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- App.vue</span><br><span class="line">- mixins&#x2F;ProductTourMixin</span><br><span class="line">-- Home.vue</span><br><span class="line">-- Analytics.vue</span><br><span class="line">-- Reports.vue</span><br></pre></td></tr></table></figure>

<p>通过这个例子可以证明，使用 mixin，能够让代码逻辑更加清晰，并且遵循 DRY 原则。这能够让你节省时间和精力，避免处理头疼的问题</p>
<h1 id="尽量拆分-Components"><a href="#尽量拆分-Components" class="headerlink" title="尽量拆分 Components"></a>尽量拆分 Components</h1><p>当我第一次用 vue 写代码时，我的一个 vue 组件有数百行到上万行代码。这个巨大的组件里包含很多逻辑，有巨大的 HTML<code>&lt;template&gt;</code>模板，有 js 方法函数。这会造成这几个问题：</p>
<ul>
<li>我写的代码没有可复用性。</li>
<li>这段代码随着时间的推移会越来越难阅读和难维护</li>
<li>和同事合作很难分工，容易产生冲突。</li>
</ul>
<p>这让我确信一点——创建一个或几个大型组件而不是许多小型组件绝对是一场噩梦。</p>
<p>那么，创建许多小的组件而不是更少的大型组件有什么好处？</p>
<ol>
<li>小型组件通常是可复用的，既节省了时间，又避免了重复的代码。</li>
<li>在大多数情况下，您是将父元素和子元素逻辑分离。 如果您更改子组件，则不会影响父元素。 你修改父元素也同样如此，只要你不修改父元素向子元素传递的 props。</li>
<li>较小的组件在大型 v-for 循环中具有性能优势，因为除非 props 更改了（非对象类型的 props），否则 Vue 不会更新它们。</li>
</ol>
<blockquote>
<p>对于大型项目而言，有必要把整个项目拆分成多个组件，能让开发过程变得更易管理。</p>
</blockquote>
<p>这段话引用自<a href="https://vuejs.org/v2/guide/#Composing-with-Components">Vue 官方文档</a> ，它说明将项目拆分成组件的重要性。</p>
<p><strong>提示：</strong>阅读你最喜欢的框架的技术文档可以学到大量的信息，因此我建议你经常阅读。</p>
<h1 id="给-Props-增加-Validate-校验"><a href="#给-Props-增加-Validate-校验" class="headerlink" title="给 Props 增加 Validate 校验"></a>给 Props 增加 Validate 校验</h1><p>校验 props 是能够让你的 Vue 程序变得更加易维护。</p>
<p>让我们来看一下 props 的错误用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">&#x27;myProp&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种定义 props 的方式仅在开发期间可以，但是在上线之前，你应该为 props 编写完整的定义。 至少，你应该为 props 定义一种类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// quick way</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    myProp: <span class="built_in">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this should be preferred</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    myProp: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是最好的方式是对 props 有完整的定义并增加校验逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  myProp: &#123;</span><br><span class="line">    type: <span class="built_in">Number</span>,</span><br><span class="line">    required: <span class="literal">true</span>,</span><br><span class="line">    validator: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果编写了 props 的校验逻辑，当传入预期之外的值，此校验逻辑可以帮你处理这种意外情况。</p>
<p>还有一项优势是，通过定义明确的 props，你能够查看 props 的定义和校验逻辑，来了解期望的值。可以将 props 视为我们了解这个组件的小型文档。 在编码时，定义好的入参规则，准确的命名这些语义化的代码比写注释更好。</p>
<p>再强调一遍，逻辑清晰的代码胜过混乱的代码，能够让你随时记住 props 的类型，减少编码过程中产生错误。</p>
<h1 id="将视图层和数据层解耦"><a href="#将视图层和数据层解耦" class="headerlink" title="将视图层和数据层解耦"></a>将视图层和数据层解耦</h1><p>Vue 不像 Angular，不提供数据层的逻辑，你需要自己编写数据层向后台的接口请求数据并返回给 Vue 进行渲染。</p>
<p>以我的经验来看，应该尽量将视图层和数据层分离。</p>
<p>为了更好地说明我的观点，我将举一个例子。 假设你有一个<code>Reports</code>组件，它包含三个子组件：<code>ReportTable</code>，<code>ReportChart</code>和<code>ReportStats</code>。</p>
<p><strong>Reports.vue</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- This example is intentionally kept simple --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;report-stats :stats=<span class="string">&quot;stats&quot;</span> /&gt;</span><br><span class="line">  &lt;report-chart :chartData=<span class="string">&quot;chartData&quot;</span> /&gt;</span><br><span class="line">  &lt;report-table :breakdown=<span class="string">&quot;breakdown&quot;</span> /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      stats: <span class="literal">null</span>,</span><br><span class="line">      chartData: <span class="literal">null</span>,</span><br><span class="line">      breakdown: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这是你的<code>Reports</code>组件的基础结构。 现在，需要从 API 中获取数据，因此你将写出以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted() &#123; this.getStats(); &#125;</span><br></pre></td></tr></table></figure>

<p>接着要编写 getStats：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">getStats</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    axios.get(<span class="string">&#x27;/api/to-get/the-data&#x27;</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stats = response.data.stats</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在看来还不错，在较小的项目中，这么处理可能还不错。 但是，将数据层和视图层分开有很多好处：</p>
<ul>
<li><p>接口层有可能在后端环境中被复用。或者当前端不用 Vue 项目，用其他框架搭建时，接口层仍然被保留。</p>
</li>
<li><p>能够帮你保持 Vue 代码逻辑清晰，易于理解。 因为视图层不需要知道数据层的复杂逻辑。</p>
</li>
<li><p>拥有一个定义明确的 API 层，有点像预控制器，可以帮助你和你的团队了解需要这些接口需要哪些参数以及每个接口是如何被调用的。</p>
</li>
</ul>
<p>那么，我们要如何改写我们的代码？</p>
<p><strong>ReportsService.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ReportsService = &#123;</span><br><span class="line">  stats: &#123;</span><br><span class="line">    index: <span class="keyword">async</span> (<span class="comment">/* params */</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> axios.get(<span class="string">&#x27;/api-link&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> response.data</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ReportsService</span><br></pre></td></tr></table></figure>

<p><strong>Reports.vue</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ReportsService from &#39;..&#x2F;services&#x2F;ReportsService&#39;; export default &#123;</span><br><span class="line">methods: &#123; async getStats() &#123; this.stats &#x3D; await ReportsService.stats.index(&#x2F;*</span><br><span class="line">params *&#x2F;); &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>我们使用简单的逻辑创建了一个服务，该服务能够与我们的后端 API 进行交互或实现数据层的逻辑。 然后，我们的 Vue 组件无需了解有关我们的 API 或数据层的更多信息，直接通过我们创建的服务获取所需的数据。</p>
<h1 id="按照-Vue-风格指南进行编码"><a href="#按照-Vue-风格指南进行编码" class="headerlink" title="按照 Vue 风格指南进行编码"></a>按照 Vue 风格指南进行编码</h1><p>深入讨论 vue 的风格指南并不在这篇文章的范围内。但是，对开发者来说，学习框架的设计原理和框架希望你如何使用它也很重要。</p>
<p>框架的创造者会制定一些标准的编码规范，社区成员在使用框架的过程中要遵循这些准则。</p>
<p>有些重要的编码规范列举如下：</p>
<h2 id="使用-data-函数，而不是-data-对象"><a href="#使用-data-函数，而不是-data-对象" class="headerlink" title="使用 data()函数，而不是 data 对象"></a>使用 data()函数，而不是 data 对象</h2><p>反例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      value: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要用 data()函数，而不是 date 对象？当 <code>data</code> 的值是一个对象时，它会在这个组件的所有实例之间共享。当组件被 A 和 B 复用时，在 A 中修改了组件的数据，会影响到 B 组件。</p>
<h2 id="给-v-for-增加-key"><a href="#给-v-for-增加-key" class="headerlink" title="给 v-for 增加 key"></a>给 v-for 增加 key</h2><p>使用 v-for 时需要增加 key，因为这样能帮助 vue 在 dom-diff 时识别出未被修改的组件，并复用该组件，从而提高渲染效率。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;my-item</span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">&quot;item in items&quot;</span></span><br><span class="line">  :key=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">  :item=<span class="string">&quot;item&quot;</span> /&gt;</span><br><span class="line">&lt;!-- or <span class="keyword">with</span> HTMl elements --&gt;</span><br><span class="line">&lt;div</span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">&quot;item in items&quot;</span></span><br><span class="line">  :key=<span class="string">&quot;item.id&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">  &#123;&#123; item.value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="避免-v-if-和-v-for-用在一起"><a href="#避免-v-if-和-v-for-用在一起" class="headerlink" title="避免 v-if 和 v-for 用在一起"></a>避免 v-if 和 v-for 用在一起</h2><p><a href="https://cn.vuejs.org/v2/style-guide/index.html#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81">vue 文档</a>明确的给出了原因。不这么做是因为 Vue 在渲染时只渲染出一小部分数据，也得在每次重渲染的时候遍历整个列表。</p>
<p>举个例子来证明一下：</p>
<p>反例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;item in items&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;item.shouldShow()&quot;</span>&gt;</span><br><span class="line">  &#123;&#123; item.value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>好的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;item in visibleItems&quot;</span>&gt;</span><br><span class="line">    &#123;&#123; item.value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>并且在<code>compued</code>中增加下属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">visibleItems</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.items.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item.shouldShow();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做的好处有这几点：</p>
<ol>
<li>计算属性<code>visibleItems</code> 只有当<code>items</code>发生变化时才会重新计算。</li>
<li><code>v-for</code>只处理<code>visibleItems</code>而不是整个<code>items</code>数组，这让渲染更加高效。</li>
<li>模板内的逻辑更加简洁清晰。解耦渲染层的罗杰，让代码的可维护性更强。</li>
</ol>
<p>如果想了解更多的编码风格，你可以阅读 <a href="https://vuejs.org/v2/style-guide/">official section of the Vue documentation</a> 这篇文档。哪怕你已经是一个有经验的 Vue 开发者，你仍然能从中学到很多内容。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>编写清晰易懂的代码会让你的同事和你的合作过程更加愉快。不用再维护大量的像意大利面一样逻辑混乱的代码，对你来说也是一件幸事。</p>
<p>如果你在做 codeview，你可以按照上述的 5 个原则来作为对代码的评价依据，如此能让你的团队贡献高质量，高效率的代码。</p>
<p>感谢阅读本文！</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie、session和jwt</title>
    <url>/2021/02/09/cookie%E3%80%81session%E5%92%8Cjwt/</url>
    <content><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ee0f3f7310542f6bace07526605f510~tplv-k3u1fbpfcp-watermark.image"></p>
<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><h2 id="1-为什么会出现-cookie"><a href="#1-为什么会出现-cookie" class="headerlink" title="1. 为什么会出现 cookie?"></a>1. 为什么会出现 cookie?</h2><p>http 是无状态的协议，导致请求不知道是哪个用户操作的。cookie 的出现就是为了解决 http 请求无状态和服务端要知道请求来源之间的矛盾。</p>
<p>cookie 会根据服务端发送的响应报文中的 <code>set-cookie</code> 字段信息，通知客户端保存 cookie。下次客户端发送请求时就会携带 cookie，服务端收到请求，根据 cookie 和服务器的记录进行比对，找到之前的状态。</p>
<span id="more"></span>

<h2 id="2-cookie-存在的问题有哪些？"><a href="#2-cookie-存在的问题有哪些？" class="headerlink" title="2. cookie 存在的问题有哪些？"></a>2. cookie 存在的问题有哪些？</h2><ul>
<li><p>cookie 会作为 http 的请求报文进行传递，所以要注意 cookie 字段的大小，一般小于 4kb。如果 cookie 存储的字段过大，浪费流量，服务端也会耗费性能解析 cookie。</p>
</li>
<li><p>cookie 保存在客户端，存在篡改或劫持的风险。故 cookie 不能存储重要信息，一般只保存凭证，服务端会根据 cookie 从数据库或 session 中查找具体信息。</p>
</li>
</ul>
<p>关于 cookie 更详细的介绍可以看维基百科 ➡️ <a href="https://en.wikipedia.org/wiki/HTTP_cookie">HTTP cookie</a></p>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><h2 id="1-session-是什么"><a href="#1-session-是什么" class="headerlink" title="1. session 是什么"></a>1. session 是什么</h2><p>session 本质是一段保存在服务端内存中的代码片段，session 的实现一般是基于 cookie 的。cookie 记录凭证，session 记录具体数据。</p>
<h2 id="2-session-存在问题"><a href="#2-session-存在问题" class="headerlink" title="2. session 存在问题"></a>2. session 存在问题</h2><ul>
<li>session 会占用内存，开销大。传统的 session 保存在内存里，每当用户登录时，在 session 做一次记录。随着认证用户的增多，服务端的开销会明显增大。</li>
<li>session 横向扩展差。页面的请求不一定是同一台服务器，如果请求打到不同服务器，那么服务器之间需要共享 session。此时需要做 session 的持久化，如果持久化失败就出现认证失败。</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4fbf18972344e079ba04a5648b3a63b~tplv-k3u1fbpfcp-watermark.image"></p>
<h1 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h1><p>jwt 全称 json web token，是目前最流行的跨域身份验证解决方案。</p>
<h2 id="1-解决的问题"><a href="#1-解决的问题" class="headerlink" title="1. 解决的问题"></a>1. 解决的问题</h2><p>传统的 session 不支持分布式架构，无法支持横向扩展，只能通过数据库来保存会话数据实现共享。如果持久层失败会出现认证失败。回到问题的本质，是因为服务端需要记录客户端对应的信息，来鉴别客户端状态。<br>而使用 jwt，服务端不需要记录客户端对应的信息。服务端通过对 token 上携带的信息进行处理能够确认这个 token 是否是有效。服务器变为无状态，使其更容易扩展。</p>
<h2 id="2-token-的组成"><a href="#2-token-的组成" class="headerlink" title="2. token 的组成"></a>2. token 的组成</h2><p>jwt 生成的 token 由 3 部分组成：头、内容、签名，通过符号<code>.</code>连接。</p>
<ol>
<li>Header 头部</li>
</ol>
<ul>
<li><p>声明类型，这里是<code>JWT</code></p>
</li>
<li><p>声明加密的算法，这里是 <code>HS256</code></p>
<p>Header 的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&#x27;typ&#x27;</span>: <span class="string">&#x27;JWT&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;alg&#x27;</span>: <span class="string">&#x27;HS256&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>Payload 内容：存放有效信息，例如过期时间，面向用户等</p>
<p>Payload 的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;exp&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Signature 签名</p>
<p>Signature 由下面两步得到</p>
<ol>
<li><p>将 base64 加密后的 Header 和 base64 加密后的 Payload 使用.连接组成的字符串</p>
</li>
<li><p>将字符串进行 Header 中声明的加密方式进行加盐 <code>secret</code> 组合加密</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&#x27;.&#x27;</span> + base64UrlEncode(payload),</span><br><span class="line">  secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="3-鉴权原理"><a href="#3-鉴权原理" class="headerlink" title="3. 鉴权原理"></a>3. 鉴权原理</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64f115797dad43a7bc92a114442c2694~tplv-k3u1fbpfcp-watermark.image"></p>
<p>① 客户端发送/login 请求到服务端 A，服务端 A 校验登录通过后生成 token。</p>
<p>② 服务端 A 将 token 返回给客户端。</p>
<p>③ 客户端发送/list 请求到服务端 B，同时在请求头里携带了 token。服务端将 token 拆解成 header+payload+signature 三部分，再次将<code> header.payload</code> 进行加密，得到新的 signature。如果<code>新的 signature</code> 和<code>旧的 signature</code> 相等则表示当前客户端是登录过的状态。</p>
<p>④ 服务端 B 校验通过，返回数据给客户端。</p>
<h2 id="4-常用的-jwt-库有"><a href="#4-常用的-jwt-库有" class="headerlink" title="4. 常用的 jwt 库有"></a>4. 常用的 jwt 库有</h2><ul>
<li><p><a href="https://www.npmjs.com/package/jwt-simple">jwt-simple</a></p>
</li>
<li><p><a href="https://www.npmjs.com/package/jsonwebtoken">jsonwebtoken</a></p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>读完这篇文章，希望你能对 cookie、session 和 jwt 有一定的了解。</p>
<p>传统的 cookie+session 的鉴权形式有一定的局限性，表现在：</p>
<ol>
<li>session 占用服务器内存</li>
<li>session 的横向扩展性不好，需要数据持久化。数据持久化如果失败影响鉴权。</li>
</ol>
<p>使用 jwt 能让服务器变成无状态的，即服务器不需保存当前请求的会话信息。实现原理是：</p>
<ul>
<li>在初次请求时，服务端生成一个 token 返回给客户端；</li>
<li>客户端再次请求时携带 token，服务端将 token 拆解成 header+payload+signature 三部分，将 <code>header.payload </code>进行加密，得到新的 signature。如果<code>新的 signature</code> 和<code>旧的 signature</code> 相等则表示通过，当前客户端是登录过的状态。</li>
</ul>
]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>create-react-app核心源码解读</title>
    <url>/2021/02/12/create-react-app%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da2ddd71d01541f8a8c78bf01d9e249c~tplv-k3u1fbpfcp-watermark.image"></p>
<p><code>create-react-app</code>是大家常用的用来创建react项目的脚手架，它的设计理念和实现思路值的我们学习。我研究了一下<code>create-react-app</code>源码，并把它的核心功能模块梳理出来。</p>
<p>下面是这篇文章的主要内容:</p>
<ol>
<li><p>简单介绍create-react-app的使用</p>
</li>
<li><p>介绍create-react-app的流程，从全局上看create-react-app是怎么创建react项目的</p>
</li>
<li><p>详细的分析create-react-app的3个核心模块的实现</p>
</li>
<li><p>总结</p>
<span id="more"></span>
<h1 id="create-react-app快速入门"><a href="#create-react-app快速入门" class="headerlink" title="create-react-app快速入门"></a>create-react-app快速入门</h1></li>
<li><p>使用create-react-app创建项目my-app：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>进入 my-app 文件夹，执行 <code>npm start</code> 启动项目</li>
</ol>
<p>默认阅读这篇文章的同学都是接触过create-react-app的人，所以不对如何使用create-react-app进行深入介绍，如果想了解详细情况请阅读官网文档（<a href="https://emojipedia.org/backhand-index-pointing-right/">👉</a> <a href="https://www.html.cn/create-react-app/docs/documentation-intro/">create-react-app</a>）。</p>
<h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><p>为了更好的了解create-react-app内部的实现原理，我们需要掌握以下这几个知识点：</p>
<h3 id="1-monorepo管理"><a href="#1-monorepo管理" class="headerlink" title="1. monorepo管理"></a>1. monorepo管理</h3><p><strong>概念</strong></p>
<p>Monorepo 是管理项目代码的一个方案，即在一个项目仓库(repo)中管理多个模块/包(package)。Monorepo的优势在于一个仓库维护多个模块，能够统一工作流，代码共享。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4af42f39751a4f02b6205e8b8cebcace~tplv-k3u1fbpfcp-watermark.image"></p>
<p>create-react-app使用Monorepo方案在packages下维护了11个包。这些包互相之间有一定的联系，放在一个仓库中维护方便代码管理。此思路也值的我们在工作中学习运用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── babel-plugin-named-asset-import</span><br><span class="line">├── babel-preset-react-app</span><br><span class="line">├── confusing-browser-globals</span><br><span class="line">├── cra-template</span><br><span class="line">├── cra-template-typescript</span><br><span class="line">├── create-react-app</span><br><span class="line">├── eslint-config-react-app</span><br><span class="line">├── react-app-polyfill</span><br><span class="line">├── react-dev-utils</span><br><span class="line">├── react-error-overlay</span><br><span class="line">└── react-scripts</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<p>我们可以用lerna或yarn workspace实现Monorepo方案，此处介绍lerna构建基础Monorepo仓库过程：</p>
<ol>
<li>进入项目目录，创建一个 lerna 管理的仓库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lerna init</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>增加一个 packages</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lerna create my-package</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>发布包。提示输入新版本并更新所有在 github 和 npm的包。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lerna publish</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>把packages下所有包的依赖安装到根 node_modules。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lerna bootstrap</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细使用文档请查看：<a href="https://emojipedia.org/backhand-index-pointing-right/">👉</a> <a href="https://lerna.js.org/">lerna官网</a></p>
<h3 id="2-node必备模块"><a href="#2-node必备模块" class="headerlink" title="2. node必备模块"></a>2. node必备模块</h3><p><strong>commander</strong></p>
<p><a href="https://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md">commander</a> 是一个完整的node.js命令行解决方案，封装了获取命令行指令</p>
<ul>
<li><code>.version</code>方法可以设置版本，其默认选项为-V和–version</li>
<li>通过<code>.arguments</code>可以为最顶层命令指定参数，对子命令而言，参数都包括在command调用之中了。尖括表示必填（eg. ），而方括号（eg. [optional]）则代表选填。</li>
<li>通过<code>.usage</code>选项可以修改帮助信息的首行提示</li>
</ul>
<p>如下demo表示，运行create-react-app myApp op1，其中myApp是必须要写的，op1可不写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const chalk &#x3D; require(&#39;chalk&#39;);</span><br><span class="line">const &#123;Command&#125; &#x3D; require(&#39;commander&#39;);</span><br><span class="line">new Command(&#39;create-react-app&#39;)</span><br><span class="line">    .version(&#39;1.0.0&#39;)</span><br><span class="line">    .arguments(&#39; [optional]&#39;)</span><br><span class="line">    .usage(&#96;$&#123;chalk.green(&#39;&#39;)&#125; [optional]&#96;)</span><br><span class="line">    .action((must,optional,...args) &#x3D;&gt; &#123;</span><br><span class="line">       console.log(must,optional,args);</span><br><span class="line">    &#125;)</span><br><span class="line">    .parse(process.argv);</span><br></pre></td></tr></table></figure>

<p><strong>cross-spawn</strong></p>
<ul>
<li><p><a href="https://www.npmjs.com/package/cross-spawn">cross-spawn</a>是node的spawn和spawnSync的跨平台解决方案</p>
</li>
<li><p><a href="https://nodejs.org/dist/latest-v15.x/docs/api/child_process.html">inherit</a>表示将相应的stdio流传给父进程或从父进程传入</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const spawn &#x3D; require(&#39;cross-spawn&#39;);</span><br><span class="line">const child &#x3D; spawn(&#39;node&#39;, [&#39;script.js&#39;,&#39;one&#39;,&#39;two&#39;,&#39;three&#39;], &#123; stdio: &#39;inherit&#39; &#125;);</span><br><span class="line">child.on(&#39;close&#39;,()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;child is done!&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">const result &#x3D; spawn.sync(&#39;node&#39;, [&#39;script.js&#39;,&#39;one&#39;,&#39;two&#39;,&#39;three&#39;], &#123; stdio: &#39;inherit&#39; &#125;);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>

<h2 id="create-react-app各模块介绍"><a href="#create-react-app各模块介绍" class="headerlink" title="create-react-app各模块介绍"></a>create-react-app各模块介绍</h2><p>create-react-app的实现过程可以用下面的流程图<a href="https://emojipedia.org/backhand-index-pointing-down/">👇</a>表示，最重要的是 <code>create-react-app</code>，<code>react-scripts</code>和<code>cra-template</code>这三个模块。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b72f051e6fb0499e9f9b69f1cc31d320~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>梳理一下流程：</p>
<ol>
<li><p>命令行输入<code>npx create-react-app my-app</code></p>
</li>
<li><p>调用<code>create-react-app</code>模块，</p>
<ul>
<li><p>创建<code>my-app</code>文件夹</p>
</li>
<li><p>写入<code>package.json</code></p>
</li>
<li><p>安装<code>react</code>, <code>react-dom</code>, <code>cra-template</code>, <code>react-scripts</code> 这四个模块</p>
</li>
<li><p>调用react-scripts的init.js</p>
</li>
</ul>
</li>
<li><p>调用<code>react-scripts</code>的init.js</p>
<ul>
<li>根据<code>cra-template/template.json</code>和 <code>my-app/package.json</code>合并出新的package.json</li>
<li>复制<code>cra-template/template</code>里的内容到my-app下</li>
<li>安装项目依赖</li>
<li>移除<code>cra-template</code></li>
</ul>
</li>
<li><p>得到目标文件夹 my-app。其中<code>package.json</code>的scripts脚本命令调用了react-scripts模块<code>bin/react-scripts</code>文件。</p>
</li>
</ol>
<p>下面重点介绍 <code>create-react-app</code>，<code>react-scripts</code>和<code>cra-template</code>这三个模块的具体实现。</p>
<h2 id="create-react-app核心模块实现"><a href="#create-react-app核心模块实现" class="headerlink" title="create-react-app核心模块实现"></a>create-react-app核心模块实现</h2><h3 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h3><p><strong>1. 主要功能</strong></p>
<p><code>create-react-app</code>包是入口，用户在命令行输入<code>npx create-react-app my-app</code>会执行</p>
<ul>
<li>和用户交互，获取项目名 my-app</li>
<li>创建my-app文件夹，安装<code>react</code>, <code>react-dom</code>, <code>cra-template</code>, <code>react-scripts</code> 这四个模块</li>
<li>调用<code>react-scripts/init.js</code></li>
</ul>
<p><strong>2.</strong> <strong>核心代码</strong></p>
<p>此处根据源码整理的逻辑图，方便大家阅读，</p>
<p><strong>3. 简化版实现</strong></p>
<p>为了便于理解，将上述逻辑简化了一下，实现了个简易版。项目地址：</p>
<p>可以通过npm i min-create-react-app -g 试用此模块。</p>
<h3 id="react-scripts"><a href="#react-scripts" class="headerlink" title="react-scripts"></a>react-scripts</h3><p><strong>1. 主要功能</strong></p>
<ul>
<li>复制cra-template到目标文件夹</li>
<li>提供webpack的功能</li>
</ul>
<p><strong>2. 实现思路</strong></p>
<p>2.1 复制cra-template到目标文件夹</p>
<p>2.2 提供scripts命令: </p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc90879e190947abba5c4e354257946e~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>关键代码：</p>
<ol>
<li>package.json中bin字段指向./bin/react-scripts.js说明命令行中执行react-scripts xxx 命令会执行此文件。</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23221adbd1074e24853cb35013c88944~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<ol start="2">
<li>./bin/react-scripts.js 中第27行和31行说明实际上执行的是对应的build.js、eject.js、start.js和test.js这四个文件。</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d11e5ee6c254dbbbe3726864330227e~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<ol start="3">
<li>react-scripts start命令</li>
</ol>
<ul>
<li><ol>
<li>设置process.env.NODE_ENV = ‘development’</li>
</ol>
</li>
<li><ol start="2">
<li>获取webpack配置文件config/webpackDevServer.config.js</li>
</ol>
</li>
<li><ol start="3">
<li>调用react-dev-utils/WebpackDevServerUtils/createCompiler生成compiler</li>
</ol>
</li>
<li><ol start="4">
<li>调用/config/webpackDevServer.config.js生成serverConfig</li>
</ol>
</li>
<li><ol start="5">
<li>启动WebpackDevServer服务</li>
</ol>
</li>
<li><ol start="6">
<li>启动浏览器，打开项目页面</li>
</ol>
</li>
</ul>
<ol start="4">
<li>build命令</li>
</ol>
<ul>
<li><ol>
<li>设置process.env.NODE_ENV = ‘production’;</li>
</ol>
</li>
<li><ol start="2">
<li>获取webpack配置文件</li>
</ol>
</li>
<li><ol start="3">
<li>清空build目录</li>
</ol>
</li>
<li><ol start="4">
<li>拷贝public目录下的文件到build目录</li>
</ol>
</li>
<li><ol start="5">
<li>创建compiler并调用run方法进行编译</li>
</ol>
</li>
</ul>
<p>react的webpack配置文件做了很多优化配置，值的我们学习：<a href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/config/webpack.config.js">github.com/facebook/cr…</a></p>
<h3 id="cra-template"><a href="#cra-template" class="headerlink" title="cra-template"></a>cra-template</h3><p><strong>1. 目录结构</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── package.json</span><br><span class="line">├── template</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── gitignore</span><br><span class="line">│   ├── public</span><br><span class="line">│   │   ├── favicon.ico</span><br><span class="line">│   │   ├── index.html</span><br><span class="line">│   │   ├── logo192.png</span><br><span class="line">│   │   ├── logo512.png</span><br><span class="line">│   │   ├── manifest.json</span><br><span class="line">│   │   └── robots.txt</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── App.css</span><br><span class="line">│       ├── App.js</span><br><span class="line">│       ├── App.test.js</span><br><span class="line">│       ├── index.css</span><br><span class="line">│       ├── index.js</span><br><span class="line">│       ├── logo.svg</span><br><span class="line">│       ├── reportWebVitals.js</span><br><span class="line">│       └── setupTests.js</span><br><span class="line">└── template.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 主要功能</strong></p>
<p>cra-template放的是react基础项目模板，会被拷贝到目标文件夹成为基础项目文件。</p>
<ul>
<li>public中存放静态资源</li>
<li>src中存放.js和.css文件</li>
<li>template.json中有此模板依赖的package，react-scripts在复制模板到目标文件夹时会将template.json和原package.json文件合并生成新的package.json</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，create-react-app的核心代码已经介绍完毕。</p>
<p>通过这篇文章，我们了解到以下几点：</p>
<ol>
<li><p><a href="https://github.com/facebook/create-react-app">create-react-app</a> 采用Monorepo方案，在一个仓库里管理create-react-app,react-scripts和cra-template等多个包，实现工作流和代码共享；</p>
</li>
<li><p><a href="https://github.com/facebook/create-react-app">create-react-app</a> 项目中，create-react-app包是入口，实现了读取命令行中的项目名，创建项目文件夹，安装react, react-dom, cra-template, react-scripts 这四个模块，最后调用react-scripts的init.js</p>
</li>
<li><p>react-scripts提供两块功能，一是复制cra-template到目标文件夹，二是提供webpack的功能</p>
</li>
<li><p>cra-template放的是react基础项目模板，会被拷贝到目标文件夹成为基础项目文件</p>
</li>
</ol>
<p>希望这篇文章能够对你有所帮助。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/facebook/create-react-app">facebook/create-react-app</a></p>
<p><a href="https://www.html.cn/create-react-app/docs/documentation-intro/">create-react-app官网文档</a></p>
<p><a href="https://www.cnblogs.com/vivotech/p/11316961.html">基于 Lerna 管理 packages 的 Monorepo 项目最佳实践</a></p>
<p><a href="https://blog.csdn.net/qiwoo_weekly/article/details/112000852">使用 MonoRepo 管理前端项目</a></p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>tapable可视化工具</title>
    <url>/2021/02/09/tapable%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><p>webpack 中的发布订阅模式是使用 <code>tapable</code> 实现的。<code>tapable</code> 比 node 自带的 <code>evevnEmitter</code> 功能更加强大，表现在 1. 一次发布能触发多个订阅钩子； 2. 事件流种类更多，分为 bail，basic, loop, waterfall。当然，学习难度也更高。我开发这个工具的目的是想将 tabable 代码转换成流程图，更直观的了解对应的 <code>tabable</code> 执行流程。</p>
<span id="more"></span>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16e36490ff5047579d782bf89c4774cf~tplv-k3u1fbpfcp-watermark.image"></p>
<p><strong>思路：</strong></p>
<ol>
<li><p>获取左侧代码片段</p>
</li>
<li><p>将代码片段经过 ast 语法树解析，解析出使用的 tapable 钩子</p>
</li>
<li><p>针对不同的钩子渲染不同的流程图</p>
</li>
</ol>
<p><strong>有了思路我变开始选择使用的库：</strong></p>
<ul>
<li>mxGraph： 绘制流程图</li>
<li>esprima + estraverse: 解析分析代码</li>
<li>monaco-editor：代码编辑器</li>
<li>Umi：基础框架</li>
</ul>
<p>当初设想的以为很简单，但是实现起来发现用到的每个库挺大，有一定的学习难度。所以这个项目是试水项目，我也算基本对这几个库入了门，后期有需要再进行深入学习。</p>
<p>页面地址：<a href="https://kinyaying.github.io/tapableUtil/dist/index.html">tapable 可视化工具</a></p>
<p>github 地址：<a href="https://github.com/kinyaying/tapableUtil">tapableUtil</a></p>
<h1 id="编辑器（monaco-editor-）"><a href="#编辑器（monaco-editor-）" class="headerlink" title="编辑器（monaco-editor ）"></a>编辑器（monaco-editor ）</h1><p><strong>核心代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化编辑器</span></span><br><span class="line"><span class="keyword">let</span> monacoInstance = monaco.editor.create(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;editor&#x27;</span>), &#123;</span><br><span class="line">  theme: <span class="string">&#x27;vs-dark&#x27;</span>,</span><br><span class="line">  scrollBeyondLastLine: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&#x27;代码片段&#x27;</span>,</span><br><span class="line">  language: <span class="string">&#x27;javascript&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2. 获取代码片段</span></span><br><span class="line"><span class="keyword">let</span> code = monacoInstance.getValue()</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的坑：</strong></p>
<p>代码中如果只引入<code> monaco-editor</code> 会发现界面是出来了，但是没有语法高亮。在控制台输入 <code>monaco.languages.getLanguages()</code>发现根本没有 javascript 语法，只有一个最基础的 plaintext。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b6aedc831e24971a32ca4c85c2eb446~tplv-k3u1fbpfcp-watermark.image"></p>
<p>此处有两种解决方案：</p>
<ol>
<li><p>代码中引入 <code>monaco</code> 自身提供的 javascript 内置语言</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;monaco-editor/esm/vs/basic-languages/javascript/javascript.contribution&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改 webpack 配置，如果使用的是 umi，也可以按照 umi 官网有提供配置方法(<a href="https://umijs.org/zh-CN/guide/boost-compile-speed#monaco-editor-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%93%E5%8C%85">monaco-editor 编辑器打包</a>)。</p>
<p>PS. umi 的 webapck 配置文件需在根目录下新建 config/config.js 文件。</p>
</li>
</ol>
<h1 id="代码解析（esprima-estraverse）"><a href="#代码解析（esprima-estraverse）" class="headerlink" title="代码解析（esprima + estraverse）"></a>代码解析（esprima + estraverse）</h1><p>esprima: 一个强大的库，将 js 代码转 ast 语法树</p>
<p>estraverse: 提供遍历 ast 语法树的钩子</p>
<p><a href="https://astexplorer.net/">astexplorer</a>: 提供可视化的代码片段转 ast 语法树网站，遍历 ast 语法树时对应此网站的结构能更方便的知道自己想获取的节点结构</p>
<p><strong>核心代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码转 ast</span></span><br><span class="line"><span class="keyword">let</span> ast = esprima.parse(code)</span><br><span class="line"><span class="comment">// 遍历 ast 语法树</span></span><br><span class="line">estraverse.traverse(ast, &#123;</span><br><span class="line">  <span class="function"><span class="title">enter</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// xxx 具体代码</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>具体的代码可以参考 <code>esprima</code> 和 <code>estraverse</code> 的官方文档，此处不再具体介绍。在遍历语法树时，可以根据 <a href="https://astexplorer.net/">astexplorer</a> 这个网页展示的语法树结构进行遍历。</p>
<h1 id="图像渲染（mxGraph）"><a href="#图像渲染（mxGraph）" class="headerlink" title="图像渲染（mxGraph）"></a>图像渲染（mxGraph）</h1><p><strong>核心代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = <span class="keyword">new</span> mxGraph(container)</span><br><span class="line"><span class="comment">// 清空画布</span></span><br><span class="line">graph.removeCells(graph.getChildVertices(graph.getDefaultParent()))</span><br><span class="line"><span class="comment">// 开始绘制</span></span><br><span class="line">graph.getModel().beginUpdate()</span><br><span class="line"><span class="comment">// 绘制图形</span></span><br><span class="line"><span class="keyword">var</span> cell = graph.insertVertex(parent, <span class="number">0</span>, tap, x, y, w, h)</span><br><span class="line"><span class="comment">// 绘制 cell 和 step 之间的连线</span></span><br><span class="line">graph.insertEdge(parent, <span class="literal">null</span>, <span class="string">&#x27;&#x27;</span>, cell, step)</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的点：</strong></p>
<ol>
<li>交互上涉及到点击按钮后重新绘制流程图，所以需要在重新绘制前清空图层中的单元。否则会出现新的图块和旧图块混在一起的情况。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">graph.removeCells(graph.getChildVertices(graph.getDefaultParent()))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>连线时为了避免 ① 和 ② 两条线黏连在一起，设置了线上的点的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> line = graph.insertEdge(parent, <span class="literal">null</span>, <span class="string">&#x27;false&#x27;</span>, step, end)</span><br><span class="line"><span class="comment">// 固定线经过的点的位置</span></span><br><span class="line">line.geometry.points = [<span class="keyword">new</span> mxPoint(pointX, pointY)]</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06757a12eca64bba8b017dbb42e7108d~tplv-k3u1fbpfcp-watermark.image"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://jgraph.github.io/mxgraph/docs/manual.html">mxGraph 官方文档</a><br><a href="http://jgraph.github.io/mxgraph/javascript/index.html">mxGraph 的各种 demo</a><br><a href="https://microsoft.github.io/monaco-editor/api/modules/monaco.editor.html">Monaco Editor API</a><br><a href="https://umijs.org/zh-CN/docs">umi 官网</a><br><a href="https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24">正则可视化工具</a></p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>wokoo脚手架（搭建篇）</title>
    <url>/2021/02/09/wokoo%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%88%E6%90%AD%E5%BB%BA%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h2 id="油猴插件-amp-wokoo-脚手架使用说明"><a href="#油猴插件-amp-wokoo-脚手架使用说明" class="headerlink" title="油猴插件 &amp; wokoo 脚手架使用说明"></a>油猴插件 &amp; wokoo 脚手架使用说明</h2><p>一款油猴插件的脚手架。如果直接开发油猴插件，开发者需要费时搭建 vue 或 react 基础项目，还需要对油猴脚本区域做对应的配置，开发体验差。</p>
<p>wokoo 可以一键式生成基础项目，并且提供基础 Tampermonkey 配置。主要提供的功能有：</p>
<ul>
<li>命令行式创建脚手架初始项目</li>
<li>根据用户选择，生成 vue、react 的基本项目</li>
<li>tampermonkey.js 文件中提供 Tampermonkey 配置</li>
</ul>
<p>关于油猴插件和 wokoo 的具体使用可以阅读 <a href="https://juejin.cn/post/6922815205575491597">5 分钟上手开发浏览器插件——油猴脚手架 wokoo</a></p>
<p>这里是 wokoo 脚手架代码：<a href="https://github.com/kinyaying/wokoo">wokoo 脚手架 github 仓库</a></p>
<p>我使用 wokoo 开发了<a href="https://greasyfork.org/zh-CN/scripts/421189-movesearch">MoveSearch</a>（划词搜索插件），欢迎大家使用</p>
<span id="more"></span>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dc027500896430f9b13bf72d400f256~tplv-k3u1fbpfcp-watermark.image"></p>
<p>wokoo 脚手架的设计参考了<a href="https://github.com/facebook/create-react-app">create-react-app</a>，我也曾经写过一篇分析 cra 源码的文章，感兴趣的同学可以阅读这篇 👉<a href="https://juejin.cn/post/6916531902773985294">create-react-app 核心源码解读</a>。</p>
<h2 id="手把手教搭建过程"><a href="#手把手教搭建过程" class="headerlink" title="手把手教搭建过程"></a>手把手教搭建过程</h2><ul>
<li>lerna: 进行项目管理</li>
<li>wokoo-scripts: 和用户交互，拉取 wokoo-template，生成对应的初始项目</li>
<li>wokoo-template: 提供模板来初始化一个有基础配置的油猴项目。模板有两种：react 和 vue</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf77f0701b274c7483a0d6aaba207640~tplv-k3u1fbpfcp-watermark.image?imageslim" alt="img"></p>
<ol>
<li>安装 lerna</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i lerna -g</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建项目目录，初始化</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir wokoo</span><br><span class="line">cd wokoo</span><br><span class="line">lerna init</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>开启 workspace，在 package.json 中增加<code>workspaces</code>配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;workspaces&quot;: [</span><br><span class="line">	&quot;packages&#x2F;*&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建子项目</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lerna create wokoo-scripts</span><br><span class="line">lerna create wokoo-template</span><br></pre></td></tr></table></figure>

<h2 id="wokoo-scripts-编写"><a href="#wokoo-scripts-编写" class="headerlink" title="wokoo-scripts 编写"></a>wokoo-scripts 编写</h2><p>wokoo-scripts 的主要功能有：</p>
<ul>
<li>commander 获取 shell 中用户键入的 projectName</li>
<li>fs.writeFile 创建文件路径</li>
<li>安装 wokoo-template 模板</li>
<li>读取模板指定后缀文件.md, .js，将 ejs 语法进行替换</li>
<li>删除多余内容</li>
<li>卸载模板</li>
</ul>
<p><strong>1.创建入口</strong></p>
<p>进入<code>packages/wokoo-scripts</code>，创建<code>bin/www</code>文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;../index.js&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>修改 package.json，增加<code>bin</code>字段配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">   &quot;wokoo&quot;: &quot;./bin/www&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在 wokoo-scripts 下创建 index.js 文件作为项目入口。</p>
<p><strong>2.安装依赖模块</strong></p>
<p>介绍下用到的第三方模块：</p>
<ul>
<li><p><a href="https://www.npmjs.com/package/chalk">chalk</a> 粉笔，丰富控制台显示的字颜色</p>
</li>
<li><p><a href="https://www.npmjs.com/package/cross-spawn">cross-spawn</a> 开启子线程</p>
</li>
<li><p><a href="https://www.npmjs.com/package/commander">commander</a> 解析命令行中的命令</p>
</li>
<li><p><a href="https://www.npmjs.com/package/fs-extra">fs-extra</a> 操作文件</p>
</li>
<li><p><a href="https://www.npmjs.com/package/inquirer">inquirer</a> 交互式命令行工具，有他就可以实现命令行的选择功能</p>
</li>
<li><p><a href="https://www.npmjs.com/package/metalsmith">metalsmith</a> 读取所有文件,实现模板渲染</p>
</li>
<li><p><a href="https://www.npmjs.com/package/consolidate">consolidate</a> 统一模板引擎</p>
</li>
</ul>
<p>安装依赖，添加软链</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install chalk cross-spawn commander fs-extra inquirer metalsmith consolidate ejs  -S</span><br><span class="line">npm link</span><br></pre></td></tr></table></figure>

<p><strong>3.实现 init 方法，读取命令行指令</strong></p>
<p>主要使用<a href="https://www.npmjs.com/package/commander">commander</a>来读取命令行中用户输入的项目名，此时在命令行执行<code>wokoo my-app</code>，能够在代码中获取到项目名 my-app</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;cross-spawn&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; Command &#125; = <span class="built_in">require</span>(<span class="string">&#x27;commander&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs-extra&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">&#x27;inquirer&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> packageJson = <span class="built_in">require</span>(<span class="string">&#x27;./package.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> program = <span class="keyword">new</span> Command()</span><br><span class="line">init()</span><br><span class="line"><span class="comment">// 程序入口，读取命令行脚本，获得项目名称</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> projectName</span><br><span class="line">  program</span><br><span class="line">    .version(packageJson.version)</span><br><span class="line">    .arguments(<span class="string">&#x27;&lt;project-directory&gt;&#x27;</span>) <span class="comment">// 项目目录名 参数格式：&lt;必选&gt; [可选]</span></span><br><span class="line">    .usage(<span class="string">`<span class="subst">$&#123;chalk.green(<span class="string">`&lt;project-directory&gt;`</span>)&#125;</span>`</span>)</span><br><span class="line">    .action(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      projectName = name</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;projectName:&#x27;</span>, projectName)</span><br><span class="line">    &#125;)</span><br><span class="line">    .parse(process.argv) <span class="comment">// [node路径，脚本路径，参数]</span></span><br><span class="line">  <span class="keyword">await</span> createApp(projectName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.createApp 方法，根据项目名生成项目</strong></p>
<p>在 run 方法中调 createApp 方法，传入 projectName。createApp 主要实现了创建文件夹，写入 package.json 的功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">appName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> root = path.resolve(appName) <span class="comment">// 要生成的项目的绝对路径</span></span><br><span class="line">  fs.ensureDirSync(appName) <span class="comment">// 没有则创建文件夹</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`create a new app in <span class="subst">$&#123;chalk.green(root)&#125;</span>`</span>)</span><br><span class="line">  <span class="comment">// 初始化package.json</span></span><br><span class="line">  <span class="keyword">const</span> packageJson = &#123;</span><br><span class="line">    name: appName,</span><br><span class="line">    version: <span class="string">&#x27;0.0.1&#x27;</span>,</span><br><span class="line">    private: <span class="literal">true</span>,</span><br><span class="line">    scripts: &#123;</span><br><span class="line">      start: <span class="string">&#x27;cross-env NODE_ENV=development webpack serve&#x27;</span>,</span><br><span class="line">      build: <span class="string">&#x27;webpack&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写入package.json</span></span><br><span class="line">  fs.writeFileSync(</span><br><span class="line">    path.join(root, <span class="string">&#x27;package.json&#x27;</span>),</span><br><span class="line">    <span class="built_in">JSON</span>.stringify(packageJson, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 改变工作目录，进入项目目录</span></span><br><span class="line">  process.chdir(root)</span><br><span class="line">  <span class="comment">// 复制项目模板，安装项目依赖等</span></span><br><span class="line">  <span class="keyword">await</span> run(root, appName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. run：复制项目模板到当前项目下，生成基础项目</strong></p>
<p>createApp 最后要调用 run 方法。run 主要做了以下几点 👇：</p>
<ol>
<li>安装 wokoo-template</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> templateName = <span class="string">&#x27;wokoo-template&#x27;</span> <span class="comment">// 对应的wokoo模板</span></span><br><span class="line"><span class="keyword">const</span> allDependencies = [templateName]</span><br><span class="line"><span class="comment">// 安装wokoo-template包</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Installing packages. This might take a couple of minutes&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Installing <span class="subst">$&#123;chalk.cyan(templateName)&#125;</span> ...`</span>)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> doAction(root, allDependencies)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Installing <span class="subst">$&#123;chalk.red(templateName)&#125;</span> failed ...`</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据用户选择的模板类型复制相应模板文件到临时文件夹 temp，替换其中的 ejs 模板，然后删除临时文件夹 temp</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择模板</span></span><br><span class="line"><span class="keyword">const</span> repos = [<span class="string">&#x27;vue&#x27;</span>, <span class="string">&#x27;react&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> &#123; targetTemplate &#125; = <span class="keyword">await</span> inquirer.prompt(&#123;</span><br><span class="line">  name: <span class="string">&#x27;targetTemplate&#x27;</span>,</span><br><span class="line">  type: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">  message: <span class="string">&#x27;which template do you prefer?&#x27;</span>,</span><br><span class="line">  choices: repos, <span class="comment">// 选择模式</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> templatePath = path.dirname(</span><br><span class="line">  <span class="built_in">require</span>.resolve(<span class="string">`<span class="subst">$&#123;templateName&#125;</span>/package.json`</span>, &#123; <span class="attr">paths</span>: [root] &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件到项目目录</span></span><br><span class="line"><span class="keyword">const</span> scriptsConfigDir = path.join(templatePath, <span class="string">&#x27;webpack.config.js&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> gitIgnoreDir = path.join(templatePath, <span class="string">&#x27;.npmignore&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> publicDir = path.join(templatePath, <span class="string">&#x27;public&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> tempDir = path.join(root, <span class="string">&#x27;temp&#x27;</span>) <span class="comment">// 临时模板路径</span></span><br><span class="line"><span class="keyword">const</span> templateDir = path.join(templatePath, <span class="string">`<span class="subst">$&#123;targetTemplate&#125;</span>-template`</span>)</span><br><span class="line"><span class="comment">// 从wokoo-template中拷贝模板到项目目录</span></span><br><span class="line"><span class="keyword">if</span> (fs.existsSync(templatePath)) &#123;</span><br><span class="line">  <span class="comment">// 将templateDir内模板拷贝到temp文件，并修改模板文件中的ejs配置项</span></span><br><span class="line">  <span class="keyword">await</span> modifyTemplate(templateDir, <span class="string">&#x27;temp&#x27;</span>, &#123;</span><br><span class="line">    projectName: appName,</span><br><span class="line">    basicProject: targetTemplate,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  fs.copySync(tempDir, root) <span class="comment">// 源 目标</span></span><br><span class="line">  fs.copySync(publicDir, root + <span class="string">&#x27;/public&#x27;</span>)</span><br><span class="line">  fs.copyFileSync(scriptsConfigDir, root + <span class="string">&#x27;/webpack.config.js&#x27;</span>)</span><br><span class="line">  fs.copyFileSync(gitIgnoreDir, root + <span class="string">&#x27;/.gitignore&#x27;</span>)</span><br><span class="line">  deleteFolder(tempDir)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(</span><br><span class="line">    <span class="string">`Could not locate supplied template: <span class="subst">$&#123;chalk.green(templatePath)&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处，我将复制的功能封装到 modifyTemplate.js 中。利用 MetalSmith 提供的方法遍历源路径下文件，利用 consolidate.ejs 将文件中的 ejs 语法替换后，将内容写入新的临时文件夹 temp 中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MetalSmith = <span class="built_in">require</span>(<span class="string">&#x27;metalsmith&#x27;</span>) <span class="comment">// 遍历文件夹</span></span><br><span class="line"><span class="keyword">let</span> &#123; render &#125; = <span class="built_in">require</span>(<span class="string">&#x27;consolidate&#x27;</span>).ejs</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line">render = promisify(render) <span class="comment">// 包装渲染方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>fromPath 源路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>toPath 目标路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleTemplate</span>(<span class="params">fromPath, toPath, config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    MetalSmith(__dirname)</span><br><span class="line">      .source(fromPath) <span class="comment">// 遍历下载的目录</span></span><br><span class="line">      .destination(path.join(path.resolve(), toPath)) <span class="comment">// 输出渲染后的结果</span></span><br><span class="line">      .use(<span class="keyword">async</span> (files, metal, done) =&gt; &#123;</span><br><span class="line">        <span class="comment">// result 替换模板内数据</span></span><br><span class="line">        <span class="keyword">let</span> result = &#123;</span><br><span class="line">          license: <span class="string">&#x27;MIT&#x27;</span>,</span><br><span class="line">          version: <span class="string">&#x27;0.0.1&#x27;</span>,</span><br><span class="line">          ...config,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> data = metal.metadata()</span><br><span class="line">        <span class="built_in">Object</span>.assign(data, result) <span class="comment">// 将询问的结果放到metadata中保证在下一个中间件中可以获取到</span></span><br><span class="line">        done()</span><br><span class="line">      &#125;)</span><br><span class="line">      .use(<span class="function">(<span class="params">files, metal, done</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Reflect</span>.ownKeys(files).forEach(<span class="keyword">async</span> (file) =&gt; &#123;</span><br><span class="line">          <span class="keyword">let</span> content = files[file].contents.toString() <span class="comment">// 获取文件中的内容</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            file.includes(<span class="string">&#x27;.js&#x27;</span>) ||</span><br><span class="line">            file.includes(<span class="string">&#x27;.json&#x27;</span>) ||</span><br><span class="line">            file.includes(<span class="string">&#x27;.txt&#x27;</span>) ||</span><br><span class="line">            file.includes(<span class="string">&#x27;.md&#x27;</span>)</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">// 如果是md或者txt才有可能是模板</span></span><br><span class="line">            <span class="keyword">if</span> (content.includes(<span class="string">&#x27;&lt;%&#x27;</span>)) &#123;</span><br><span class="line">              <span class="comment">// 文件中用&lt;% 我才需要编译</span></span><br><span class="line">              content = <span class="keyword">await</span> render(content, metal.metadata()) <span class="comment">// 用数据渲染模板</span></span><br><span class="line">              files[file].contents = Buffer.from(content) <span class="comment">// 渲染好的结果替换即可</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        done()</span><br><span class="line">      &#125;)</span><br><span class="line">      .build(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 执行中间件</span></span><br><span class="line">        <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">          resovle()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = handleTemplate</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>合并 template.json 和 package.json，生成新的 package.json 并再次执行<code>npm install</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并template.json和package.json</span></span><br><span class="line"><span class="keyword">let</span> tempPkg = fs.readFileSync(root + <span class="string">&#x27;/template.json&#x27;</span>).toString()</span><br><span class="line"><span class="keyword">let</span> pkg = fs.readFileSync(root + <span class="string">&#x27;/package.json&#x27;</span>).toString()</span><br><span class="line"><span class="keyword">const</span> tempPkgJson = <span class="built_in">JSON</span>.parse(tempPkg)</span><br><span class="line"><span class="keyword">const</span> pkgJson = <span class="built_in">JSON</span>.parse(pkg)</span><br><span class="line"></span><br><span class="line">pkgJson.dependencies = &#123;</span><br><span class="line">  ...pkgJson.dependencies,</span><br><span class="line">  ...tempPkgJson.package.dependencies,</span><br><span class="line">&#125;</span><br><span class="line">pkgJson.devDependencies = &#123;</span><br><span class="line">  ...tempPkgJson.package.devDependencies,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编写package.json</span></span><br><span class="line">fs.writeFileSync(</span><br><span class="line">  path.join(root, <span class="string">&#x27;package.json&#x27;</span>),</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(pkgJson, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line">fs.unlinkSync(path.join(root, <span class="string">&#x27;template.json&#x27;</span>)) <span class="comment">// 删除template.json文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次根据dependenciesToInstall执行npm install</span></span><br><span class="line"><span class="keyword">const</span> dependenciesToInstall = <span class="built_in">Object</span>.entries(&#123;</span><br><span class="line">  ...pkgJson.dependencies,</span><br><span class="line">  ...pkgJson.devDependencies,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> newDependencies = []</span><br><span class="line"><span class="keyword">if</span> (dependenciesToInstall.length) &#123;</span><br><span class="line">  newDependencies = newDependencies.concat(</span><br><span class="line">    dependenciesToInstall.map(<span class="function">(<span class="params">[dependency, version]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;dependency&#125;</span>@<span class="subst">$&#123;version&#125;</span>`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">await</span> doAction(root, newDependencies)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;chalk.cyan(<span class="string">&#x27;Installing succeed!&#x27;</span>)&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>卸载 wokoo-template</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> doAction(root, <span class="string">&#x27;wokoo-template&#x27;</span>, <span class="string">&#x27;uninstall&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>流程上的实现介绍完了，下面两个方法是我封装的功能性方法</p>
<p><strong>doAction：使用 npm 安装或卸载项目依赖</strong></p>
<p>使用<a href="https://www.npmjs.com/package/cross-spawn">cross-spawn</a>开启子线程，在子线程中执行<code>npm install</code> 或 <code>npm uninstall</code>的命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doAction</span>(<span class="params">root, allDependencies, action = <span class="string">&#x27;install&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">typeof</span> allDependencies === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">    ? (allDependencies = [allDependencies])</span><br><span class="line">    : <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> command = <span class="string">&#x27;npm&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> args = [</span><br><span class="line">      action,</span><br><span class="line">      <span class="string">&#x27;--save&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;--save-exact&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;--loglevel&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">      ...allDependencies,</span><br><span class="line">      <span class="string">&#x27;--cwd&#x27;</span>,</span><br><span class="line">      root,</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">const</span> child = spawn(command, args, &#123; <span class="attr">stdio</span>: <span class="string">&#x27;inherit&#x27;</span> &#125;)</span><br><span class="line">    child.on(<span class="string">&#x27;close&#x27;</span>, resolve) <span class="comment">// 安装成功后触发resolve</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>deleteFolder: 递归删除文件、文件夹，入参是 path 文件路径</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteFolder</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> files = []</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(path)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fs.statSync(path).isDirectory()) &#123;</span><br><span class="line">      <span class="comment">// path是文件，直接删除</span></span><br><span class="line">      fs.unlinkSync(path)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 删除文件夹</span></span><br><span class="line">      files = fs.readdirSync(path)</span><br><span class="line">      files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> curPath = path + <span class="string">&#x27;/&#x27;</span> + file</span><br><span class="line">        deleteFolder(curPath)</span><br><span class="line">      &#125;)</span><br><span class="line">      fs.rmdirSync(path)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wokoo-template-编写"><a href="#wokoo-template-编写" class="headerlink" title="wokoo-template 编写"></a>wokoo-template 编写</h2><ul>
<li>分为 vue-template 和 react-template</li>
<li>vue-template 和 react-template 分别对应 webpack 配置的一个 vue 或 react 基础项目</li>
<li>使用 ejs 模板，实现 wokoo-scripts 注入变量</li>
</ul>
<p>template 相对来说比较简单，使用 webpack+vue 或 react 分别搭建了一个轻量级项目。</p>
<p>具体代码可看 👉<a href="https://github.com/kinyaying/wokoo/tree/master/packages/wokoo-template">wokoo/wokoo-template</a></p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>在执行<code>lerna publish</code>之前，先看下自己的项目下用到的文件或文件夹是否在 package.json <code>files</code>字段中。只有在 files 中的文件或文件夹才会真正的被发布上去。</p>
<ol>
<li>在 wokoo-scripts 的 package.json 的<code>files</code>字段中增加”modifyTemplate.js”</li>
<li>在 wokoo-template 的 package.json 的<code>files</code>字段中增加”react-template”, “vue-template”,”public”,”webpack.config.js”,”.gitignore”</li>
</ol>
<p>我之前就忘记往 files 字段添加，导致 publish 上去后发现丢文件了。具有问题可阅读：<a href="https://stackoverflow.com/questions/27049192/npm-publish-isnt-including-all-my-files">https://stackoverflow.com/questions/27049192/npm-publish-isnt-including-all-my-files</a></p>
<p>最后一步就大功告成了！🎉</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lerna publish</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i wokoo -g</span><br><span class="line">wokoo my-app</span><br></pre></td></tr></table></figure>

<p>具体使用过程可以阅读<a href="https://juejin.cn/post/6922815205575491597">油猴脚手架 wokoo 使用说明</a></p>
<p>都读到这里了，给你鼓个掌吧 👏👏👏</p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码角度理解npm</title>
    <url>/2021/02/12/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3npm%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d8c3afabef14766adf570beb5a06e75~tplv-k3u1fbpfcp-watermark.image"></p>
<p>我在整理npm相关知识时，发现有些问题比较困惑，网上也没有从源码层面解释npm的文章，所以我去看了源码来解决我的困惑。为了加深理解，我把源码里的重点内容整理出来，希望大家在读完后也能够对npm有更深的理解。</p>
<span id="more"></span>
<h2 id="什么是npm"><a href="#什么是npm" class="headerlink" title="什么是npm"></a>什么是npm</h2><p>npm全称_node package manager_，<a href="https://zh.wikipedia.org/zh-hans/Node.js#">维基百科关于Node.js</a>的介绍中指明<a href="https://zh.wikipedia.org/zh-hans/Node.js#npm">npm</a>是Node.js附带的包管理器。下载安装node时会附加安装了npm。npm是一个命令行工具，用于从NPM Registry中下载、安装Node.js程序，同时解决依赖问题。npm提高了开发的速度，因为它能够负责第三方Node.js程序的安装与管理。</p>
<p><a href="https://emojipedia.org/backhand-index-pointing-right/">👉</a> <a href="https://docs.npmjs.com/about-npm/">npm官网文档</a></p>
<p><a href="https://emojipedia.org/backhand-index-pointing-right/">👉</a> <a href="https://github.com/npm/cli">npm git仓库</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>npm是Node.js附带的包管理器，也就是说安装node完后，自动安装npm。</p>
<ul>
<li><p>node可在官网下载指定版本安装 <a href="https://nodejs.org/en/download/">node官网</a></p>
</li>
<li><p>如果是mac电脑，也可以使用homebrew安装。打开终端，在命令行中输入</p>
<p>brew install node</p>
</li>
</ul>
<p>下载node包打开后也能看到里面默认带了npm和npx</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb1953197a2b4519a056f4049ca038ee~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在开发代码阶段，我们时常要使用到 npm：</p>
<ul>
<li>在初始化项目时，我们会使用<code>npm init -y</code> 命令来生成<code>package.json</code>文件</li>
<li>然后再<code>npm install &lt;packageName&gt;</code>安装模块</li>
<li>开发代码完成后需要在package.json中配置scripts字段start，再通过<code>npm run start</code>执行代码</li>
</ul>
<p><strong>那么实际上执行npm命令的调用关系是什么？实际是执行哪个脚本呢？</strong></p>
<p>我们可以在终端任意路径下输入<code>which npm</code>查看npm执行文件所在的位置，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可知npm命令实际上是执行的是/usr/local/bin/npm文件。继续输入<code>ll /usr/local/bin/npm</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; lrwxr-xr-x 1 kin admin 46B 4 7 2020 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npm&#x2F;bin&#x2F;npm-cli.js</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>也就是说_/usr/local/bin/npm_是个软链，实际执行的是_/usr/local/lib/node_modules/npm/bin/npm-cli.js_文件</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b37ae13045e04038b7e3cd98946410cf~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<h2 id="如何调试npm源码"><a href="#如何调试npm源码" class="headerlink" title="如何调试npm源码"></a>如何调试npm源码</h2><p>首先去 <a href="https://github.com/npm/cli">npm的git仓库</a>把代码拉取到本地，开始调试源码。</p>
<p>这里介绍一个比较取巧的方式调试，先确认一下你使用的IDE是VSCode。</p>
<ol>
<li>在项目根路径的package.json中给scripts字段添加一行命令<a href="https://emojipedia.org/backhand-index-pointing-down/">👇</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;debugger&quot;: &quot;node .&#x2F;bin&#x2F;npm-cli.js install moment&quot;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>解释一下，因为npm本质上就是<code>node ./bin/npm-cli.js</code>，故使用<code>node ./bin/npm-cli.js</code> 替代npm即可。也就是说配置的<code>node ./bin/npm-cli.js install moment</code>等价于 <code>npm install moment</code>。</p>
<ol start="2">
<li>点击scripts字段上面的Debug小图标</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f24593bd1ab4acdbb629ea6bc480221~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<ol start="3">
<li>弹窗中选择debugger，进入调试模式</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eab956a25c94db88212a4531184eddb~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>这里将从这几个方面分析npm源码：</p>
<ol>
<li>整体介绍</li>
<li>npm常用命令的实现，包括</li>
</ol>
<ul>
<li><code>npm init</code></li>
<li><code>npm install &lt;packageName&gt;</code></li>
<li><code>npm run scripts</code></li>
</ul>
<h3 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1. 整体介绍"></a>1. 整体介绍</h3><p>根据上面的分析可知，npm实际执行的文件是/usr/local/lib/node_modules/npm/bin/npm-cli.js，查看npm-cli.js文件的代码可知：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env node </span><br><span class="line">require(&#39;..&#x2F;lib&#x2F;cli.js&#39;)(process)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>内部实际调用的是/npm/lib/cli.js，核心逻辑在56行，从npm.commands上获取指令所对应的文件，如果存在就执行此文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const impl &#x3D; npm.commands[cmd]</span><br><span class="line">if (impl)</span><br><span class="line">  impl(npm.argv, errorHandler)</span><br><span class="line">else &#123;</span><br><span class="line">  npm.config.set(&#39;usage&#39;, false)</span><br><span class="line">  npm.argv.unshift(cmd)</span><br><span class="line">  npm.commands.help(npm.argv, errorHandler)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>也就是说npm run xxx命令最后会执行相对应的文件</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a8459002ce459598f49a95ce7c7fd8~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<h3 id="2-npm常用命令的实现"><a href="#2-npm常用命令的实现" class="headerlink" title="2. npm常用命令的实现"></a>2. npm常用命令的实现</h3><p>重点介绍这几个常用命令<code>npm init</code>，<code>npm install &lt;packageName&gt;</code>和 <code>npm run &lt;scripts&gt;</code></p>
<p><strong>npm init。</strong></p>
<p>如上分析可知，<code>npm init</code> 会对应执行<a href="https://github.com/npm/cli/blob/latest/lib/init.js">lib/init.js</a>，核心代码从71行开始，调用initJson()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">await new Promise((res, rej) &#x3D;&gt; &#123;</span><br><span class="line">    initJson(dir, initFile, npm.config, (er, data) &#x3D;&gt; &#123;</span><br><span class="line">      npm.log.resume()</span><br><span class="line">      npm.log.enableProgress()</span><br><span class="line">      npm.log.silly(&#39;package data&#39;, data)</span><br><span class="line">      if (er &amp;&amp; er.message &#x3D;&#x3D;&#x3D; &#39;canceled&#39;) &#123;</span><br><span class="line">        npm.log.warn(&#39;init&#39;, &#39;canceled&#39;)</span><br><span class="line">        return res()</span><br><span class="line">      &#125;</span><br><span class="line">      if (er)</span><br><span class="line">        rej(er)</span><br><span class="line">      else &#123;</span><br><span class="line">        npm.log.info(&#39;init&#39;, &#39;written successfully&#39;)</span><br><span class="line">        res(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p> initJson是本质上调用的是init-package-json 中的init方法。主要做的就是写入package.json文件</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4772ce381e9e49ba8baa182cb001101f~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>读完这篇文章，你应该对npm的实现机制有了基本的了解：</p>
<ol>
<li><p>npm是node.js附带的包管理器，在安装node时会附带安装上</p>
</li>
<li><p>npm本质是一段node脚本，我们执行npm命令其实就是执行<code>node /usr/local/lib/node_modules/npm/bin/npm-cli.js</code></p>
</li>
<li><p>最后分享一点阅读源码的心得：</p>
</li>
</ol>
<ul>
<li>读源码时要抓大放小，先把整体脉络整理出来，在针对各个细节进行分析；</li>
<li>抓住核心逻辑，读进去还能读出来，就是能表达出源码做了啥；</li>
<li>进阶段位就是学习源码里的优秀思想，学以致用吧</li>
</ul>
<p>—</p>
<p>希望这篇文章能够给你有所帮助，对文章中的内容有疑问的地方欢迎一起探讨。</p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试必知必会1——ES6基础</title>
    <url>/2021/02/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A1%E2%80%94%E2%80%94ES6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1-symbol"><a href="#1-symbol" class="headerlink" title="1. symbol"></a>1. symbol</h1><h3 id="Symbol-的基本用法"><a href="#Symbol-的基本用法" class="headerlink" title="Symbol 的基本用法"></a>Symbol 的基本用法</h3><p>Symbol 能够创建独一无二的类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;kin&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;kin&#x27;</span>)</span><br><span class="line">s1 === s2 <span class="comment">// 结果是false</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>可以作为对象的 key 使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lucy&#x27;</span>,</span><br><span class="line">  say: <span class="string">&#x27;hello world&#x27;</span>,</span><br><span class="line">  [s1]: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Symbol 作为 key 时，Symbol 属性不能被 for in 枚举，能够通过 Reflect.ownKeys(obj)获取</p>
<h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for"></a>Symbol.for</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;kin&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s4 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;kin&#x27;</span>)</span><br><span class="line">s3 === s4 <span class="comment">// 复用</span></span><br></pre></td></tr></table></figure>

<h3 id="Symbol-可以做元编程"><a href="#Symbol-可以做元编程" class="headerlink" title="Symbol 可以做元编程"></a>Symbol 可以做元编程</h3><p>元编程即可以改写 js 语法本身</p>
<p><strong>Symbol.toStringTag: 修改数据类型</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&#x27;kin&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj) <span class="comment">// 结果 &quot;[object kin]&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Symbol.toPrimitive: 隐式类型转化</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="number">1</span>) <span class="comment">// [object Object]1</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](type) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="number">1</span>) <span class="comment">// 1231</span></span><br></pre></td></tr></table></figure>

<p><strong>Symbol.hasInstance: 改写 instanceof 的功能</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.hasInstance](value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(&#123; <span class="attr">name</span>: <span class="string">&#x27;kin&#x27;</span> &#125; <span class="keyword">instanceof</span> instance) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="2-set、map-与-weakSet、weakMap"><a href="#2-set、map-与-weakSet、weakMap" class="headerlink" title="2. set、map 与 weakSet、weakMap"></a>2. set、map 与 weakSet、weakMap</h1><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set"><code>Set</code></a>对象是值的集合，Set 中的元素只会<strong>出现一次</strong>，即 Set 中的元素是唯一的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong></p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/add"><code>Set.prototype.add(*value*)</code></a></p>
<p>在<code>Set</code>对象尾部添加一个元素。返回该<code>Set</code>对象。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/entries"><code>Set.prototype.entries()</code></a></p>
<p>返回一个新的迭代器对象，该对象包含<code>Set</code>对象中的按插入顺序排列的所有元素的值的<code>[value, value]</code>数组。为了使这个方法和<code>Map</code>对象保持相似， 每个值的键和值相等。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/has"><code>Set.prototype.has(*value*)</code></a></p>
<p>返回一个布尔值，表示该值在<code>Set</code>中存在与否。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach"><code>Set.prototype.forEach(*callbackFn*[, *thisArg*])</code></a></p>
<p>按照插入顺序，为 Set 对象中的每一个值调用一次 callBackFn。如果提供了<code>thisArg</code>参数，回调中的<code>this</code>会是这个参数。</p>
</li>
</ul>
<p><strong>处理交集、并集、差集</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Map</span>()) <span class="comment">// &quot;[object Map]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Set</span>()) <span class="comment">// &quot;[object Set]&quot;</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment">// 求并集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([...arr1, ...arr2])</span><br><span class="line">  <span class="keyword">return</span> [...s]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求交集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span>(<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2)</span><br><span class="line">  <span class="keyword">return</span> arr1.filter(<span class="function">(<span class="params">one</span>) =&gt;</span> s2.has(one))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a></strong> 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">原始值</a>) 都可以作为一个键或一个值。</p>
<p><strong>常用方法</strong></p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/get"><code>Map.prototype.get(key)</code></a></p>
<p>返回键对应的值，如果不存在，则返回 undefined。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/set"><code>Map.prototype.set(key, value)</code></a></p>
<p>设置 Map 对象中键的值。返回该 Map 对象。</p>
</li>
</ul>
<p><strong>WeakMap 与 Map</strong></p>
<ul>
<li>WeakMap 的 key 只能是对象，Map 的 key 可以是任意类型</li>
<li>key 被置为 null 时，WeakMap 会被垃圾回收，Map 则不会被垃圾回收。举例如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> my = <span class="keyword">new</span> Test()</span><br><span class="line"><span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">newMap.set(my, <span class="number">1</span>)</span><br><span class="line">my = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>此处使用 Map，当 my 变成 null 时，newMap 中仍然保留 Test 实例，class Test 仍然在内存中，没被销毁。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb10e569e05b4e77b5e4edcb805efcb8~tplv-k3u1fbpfcp-watermark.image"><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67ee097c845d452fafa8b63b38501b7e~tplv-k3u1fbpfcp-watermark.image"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> my = <span class="keyword">new</span> Test()</span><br><span class="line"><span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">newMap.set(my, <span class="number">1</span>)</span><br><span class="line">my = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>而使用 WeakMap 时，当 my 被置为 null 后，newMap 中 Test 实例也不存在，class Test 被垃圾回收机制销毁了。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0243106a9874c599e27de1c3e3376e2~tplv-k3u1fbpfcp-watermark.image"><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f471553e23a74db3a64073b4a73bf8b6~tplv-k3u1fbpfcp-watermark.image"></p>
<h1 id="3-Reflect"><a href="#3-Reflect" class="headerlink" title="3. Reflect"></a>3. Reflect</h1><p>Es6 后续新增的方法放 Reflect 上</p>
<h3 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h3><p>获取对象的属性列表</p>
<h3 id="Reflect-apply"><a href="#Reflect-apply" class="headerlink" title="Reflect.apply"></a>Reflect.apply</h3><p>我们在源码中经常看到<code>Function.prototype.apply.call</code>的写法，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...argvs</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">sum.apply = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;apply&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.apply.call(sum, <span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>因为直接调用函数的 apply 方法没法确保调用的是原生的 apply，可能已经被改写了。所以通过<code>Function.prototype.apply.call</code>来确保调用到原生的 apply。</p>
<p>可以这样理解 call 的功能：1. 改变 apply 中的 this 为 sum，2. 让 apply 执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply.call(sum, <span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="built_in">Function</span>.prototype.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 等价于apply执行，并且apply内的this是sum</span></span><br><span class="line">sum([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 等价于sum执行，并且this是null</span></span><br></pre></td></tr></table></figure>

<p>Reflect 上也有 apply 方法，并且写法更加简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.apply(sum, <span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<h1 id="4-reduce"><a href="#4-reduce" class="headerlink" title="4. reduce"></a>4. reduce</h1><p>数组上提供的方法，能够收敛数组，把数组转化成其他类型数据</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>数组不能为空，若为空则 reduce 第二个参数必须填，否则报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].reduce(<span class="function">(<span class="params">prev, current, index, array</span>) =&gt;</span> &#123;&#125;, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">[].reduce(<span class="function">(<span class="params">prev, current, index, array</span>) =&gt;</span> &#123;&#125;, <span class="string">&#x27;&#x27;</span>) <span class="comment">// 数组不能空，若为空则reduce第二个参数必须填，否则报错</span></span><br></pre></td></tr></table></figure>

<h3 id="reduce-实现"><a href="#reduce-实现" class="headerlink" title="reduce 实现"></a>reduce 实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce = <span class="function"><span class="keyword">function</span> (<span class="params">callback, prev</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prev) &#123;</span><br><span class="line">      prev = callback(<span class="built_in">this</span>[i], <span class="built_in">this</span>[i + <span class="number">1</span>], i + <span class="number">1</span>, <span class="built_in">this</span>)</span><br><span class="line">      i++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev = callback(prev, <span class="built_in">this</span>[i], i, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用-reduce-实现-map"><a href="#用-reduce-实现-map" class="headerlink" title="用 reduce 实现 map"></a>用 reduce 实现 map</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">prev, next, index</span>) =&gt;</span> &#123;</span><br><span class="line">    prev.push(cb(next, index, <span class="built_in">this</span>))</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用-reduce-实现拍平多维数组-flat"><a href="#用-reduce-实现拍平多维数组-flat" class="headerlink" title="用 reduce 实现拍平多维数组 flat"></a>用 reduce 实现拍平多维数组 flat</h3><p>数组有一个自带的<code>flat</code>方法，能够拍平多维数组。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">4</span>]]].flat(<span class="number">2</span>) <span class="comment">// [1, 2, 3, 1, 2, 4]</span></span><br></pre></td></tr></table></figure>

<p>用 reduce 也能够实现拍平多维数组的功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.flat = <span class="function"><span class="keyword">function</span> (<span class="params">level</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.reduce(<span class="function">(<span class="params">prev, next, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(next)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        next = next.flat(--level)</span><br><span class="line">      &#125;</span><br><span class="line">      prev = [...prev, ...next]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev.push(next)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用-reduce-实现-compose"><a href="#用-reduce-实现-compose" class="headerlink" title="用 reduce 实现 compose"></a>用 reduce 实现 compose</h3><p><code>compose</code>即组合函数，用来把多个函数组合起来，常用在中间件中。比如有 3 个函数，<code>sum</code>，<code>len</code>，<code>addPrefix</code>，需要一层层的去调用这三个函数<code>addPrefix(len(sum(&#39;a&#39;, &#39;b&#39;)))</code>。我们也可以通过<code>compose(sum, len, addPrefix)</code>来实现这个功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">len</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.length</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPrefix</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;￥&#x27;</span> + str</span><br><span class="line">&#125;</span><br><span class="line">addPrefix(len(sum(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)))</span><br></pre></td></tr></table></figure>

<p>通过执行<code>compose(sum, len, addPrefix)</code>产生一个新函数 fn，再调用<code>fn(&#39;a&#39;, &#39;b&#39;)</code>实现 3 个函数的组合调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fns.reduce(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...argvs</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> prev(next(...argvs))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = compose(addPrefix, len, sum)</span><br><span class="line">fn(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>为了更好的理解 compose 的实际执行结果，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = compose(addPrefix, len, sum) <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">...argvs2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> (<span class="params">...argvs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addPrefix(len(...argvs))</span><br><span class="line">  &#125;)(sum(...argvs2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-defineProperty"><a href="#5-defineProperty" class="headerlink" title="5. defineProperty"></a>5. defineProperty</h1><p>作用：对 object 的每个属性用此方法定义，可以使用 get 和 set 拦截对象的取值和设置值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;,</span><br><span class="line">  _a = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _a</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    _a = value</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">obj.a = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>可添加描述符</p>
<p><code>enumerable</code> 和<code>configurable</code>都是描述符</p>
<ul>
<li><code>enumerable</code> 表示 obj 是否可以被 for in 或 Object.keys 枚举</li>
<li><code>configurable</code>表示 obj 是否可以被删除，例如<code>delete obj.a </code></li>
</ul>
</li>
<li><p>使用 set 和 get 时需要借助第三方变量实现对<code>a</code>属性的监控</p>
</li>
<li><p>缺点：如果要把对象的属性全部转化成 getter + setter，需要遍历所有对象，用 defineProperty 重新定义属性，性能不高</p>
<ul>
<li><p>数组采用这种方式，索引很多，性能很差</p>
</li>
<li><p>对象中嵌套对象，需要递归处理</p>
</li>
</ul>
</li>
</ol>
<h1 id="6-proxy"><a href="#6-proxy" class="headerlink" title="6. proxy"></a>6. proxy</h1><p>作用：使用 get 和 set 拦截对象属性的取值和设置值。</p>
<p>优点：proxy 是不用改写原对象，不用对 object 的属性进行重新定义，性能高。如果访问到的属性是对象时，再代理即可，不用递归。</p>
<p>缺点：proxy 是 es6 的 api, 但是兼容性差</p>
<p><a href="https://github.com/vuejs/vue-next">vue3</a> 中对数据的拦截就改用了 proxy。</p>
<p>常用的 api:</p>
<ul>
<li>get：获取属性时触发，例如 proxy.xxx</li>
<li>set：设置 proxy 属性时触发，proxy.a = 1</li>
<li>ownKeys：获取 proxy 的 key 触发，Object.getOwnPropertyNames(proxy)或 Reflect.ownKeys 或 Object.keys 都会触发</li>
<li>deleteProperty：删除 proxy 上的属性时触发，eg. delete proxy.xxx 触发</li>
<li>has：使用 in 语法时触发，eg. ‘a’ in proxy</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">xxx</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Proxy get&#x27;</span>, <span class="built_in">arguments</span>, <span class="built_in">Reflect</span>.get(...arguments))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments)</span><br><span class="line">  &#125;, <span class="comment">// proxy.xxx</span></span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Proxy set&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">ownKeys</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Object.getOwnPropertyNames(proxy) 或Reflect.ownKeys 或 Object.keys</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Proxy ownKeys&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(target)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// delete proxy.xxx 触发</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Proxy deleteProperty&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">delete</span> target[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Proxy has&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target</span><br><span class="line">  &#125;, <span class="comment">// &#x27;a&#x27; in proxy</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="7-深拷贝和浅拷贝"><a href="#7-深拷贝和浅拷贝" class="headerlink" title="7. 深拷贝和浅拷贝"></a>7. 深拷贝和浅拷贝</h1><ul>
<li><p><strong>… 展开运算符</strong></p>
<p>… 等价于 Object.assign 都是浅拷贝</p>
</li>
<li><p><strong>实现一个深拷贝</strong></p>
</li>
</ul>
<ol>
<li><p>JSON.string + JSON.parse</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="literal">undefined</span> &#125;))</span><br></pre></td></tr></table></figure>

<p>缺陷： 正则，函数，日期， undefined 这些类型不支持</p>
</li>
<li><p>递归对象，把对象属性都进行拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录拷贝后的结果</span></span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="comment">// 正则 日期 函数 set map</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="keyword">if</span> (hash.has(obj)) <span class="keyword">return</span> hash.get(obj) <span class="comment">// 返回上次拷贝的结果</span></span><br><span class="line">  <span class="comment">// 数组 || 对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="keyword">new</span> obj.constructor()</span><br><span class="line">  hash.set(obj, newObj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 不拷贝原型上的方法</span></span><br><span class="line">      newObj[key] = deepClone(obj[key], hash)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>其中增加<code>if (hash.has(obj)) return hash.get(obj) </code> 是为了避免循环引用。每次拷贝完对象的属性后都存储在 hash 里，在下次拷贝属性前先看一下是否有，如果有就直接返回。循环引用的测试例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj.b = &#123;&#125;</span><br><span class="line">obj.b.a = obj.b</span><br><span class="line"><span class="built_in">console</span>.log(deepClone(obj))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title>图解koa2核心原理</title>
    <url>/2021/02/12/%E5%9B%BE%E8%A7%A3koa2%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>koa是经常使用的node端框架，它封装了一系列node方法，通过它的api让写服务变得更加方便。而且相比express，koa支持promise写法，更加符合现在的前端代码编写习惯，代码可读性更强。koa相比express更加短小，更多的功能是通过插件的形式实现的，它的设计思路很值得我们参考。</p>
<p>本篇文章将koa的逻辑用流程图表示，让我们理解起来更加简单。</p>
<span id="more"></span>
<h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae9cf32b2dd9416087eb83164269820e~tplv-k3u1fbpfcp-watermark.image"></p>
<p>koa的代码十分短小精悍，有效的代码文件就lib目录下的4个文件，从package.json里的<code>main</code>字段可知入口文件是<code>lib/application.js</code>。koa的主要功能由application.js提供，context.js，request.js和response.js 这三个文件主要是对原生req和res进行扩展，给koa的请求上下文ctx提供更丰富的功能。</p>
<h1 id="Koa创建服务"><a href="#Koa创建服务" class="headerlink" title="Koa创建服务"></a>Koa创建服务</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="comment">// 1. 创建koa应用</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="comment">// 2. koa中间件</span></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 3. 起服务</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>如上示例代码，三步就能够起一个简单的koa服务。<a href="https://github.com/kinyaying/koa-demo/blob/main/demo1.js">👉 demo1</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9cd91d1c7594d759ad147c7fa7468b4~tplv-k3u1fbpfcp-watermark.image"></p>
<p>起服务各个步骤的详细解析如下：</p>
<p><strong>1. new Koa()</strong><br>调用了koa的constructor方法，进行了context、request、response的初始化</p>
<p><strong>2. app.use()</strong><br>将中间件函数存储在middleware中</p>
<p><strong>3. app.listen()</strong></p>
<ul>
<li>起http服务</li>
<li>监听请求，如果有请求进来，创建koa的请求上下文ctx，依次调middleware里的中间件函数对请求进行处理。</li>
</ul>
<h1 id="中间件原理"><a href="#中间件原理" class="headerlink" title="中间件原理"></a>中间件原理</h1><p>koa的中间件使用的是洋葱模型，具体我们通过下面两个例子深入了解。</p>
<h3 id="1-koa中间件使用"><a href="#1-koa中间件使用" class="headerlink" title="1. koa中间件使用"></a>1. koa中间件使用</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4cb22cf5816444798038a1cee5eb9aa~tplv-k3u1fbpfcp-watermark.image"></p>
<p><strong>情况一： <code>await next()</code></strong></p>
<p>koa中间件正常的使用需要在next前加await，这样能确保请求被每一个中间件都处理完再返回响应。<a href="https://github.com/kinyaying/koa-demo/blob/main/demo2.js">👉 demo2</a><br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7431b034d26541ed85f64f96b3e8833c~tplv-k3u1fbpfcp-watermark.image"></p>
<p><strong>情况二： 直接<code>next()</code> ，没用<code>await</code></strong></p>
<p>如果<code>next</code>前没有加<code>await</code>，那么中间件1相当于同步代码，如果中间件2有异步代码，中间件1不会等待中间件2执行完而是直接返回。这样会导致请求没有被后面的中间件处理就返回了，我们在应用中尽量避免此情况。<a href="https://github.com/kinyaying/koa-demo/blob/main/demo3.js">👉 demo3</a></p>
<p><strong>小结：</strong></p>
<p>我们在使用koa中间件时确保使用的规范性，用<code>await next()</code>这种方式，而不是<code>next()</code>这种。因为我们没法确保每个中间件都没有异步代码，使用<code>await next()</code>能等待异步代码执行完毕再往下执行。</p>
<h3 id="2-koa中间件原理"><a href="#2-koa中间件原理" class="headerlink" title="2. koa中间件原理"></a>2. koa中间件原理</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6765b516fbb7400299151aac96dbfc96~tplv-k3u1fbpfcp-watermark.image"></p>
<p>koa中间件是通过<a href="https://github.com/koajs/compose">koa-compose</a>实现的。为了方便理解，我将compose函数简化一下。</p>
<p><strong>compose函数简化版</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// koa 核心代码</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === middlewares.length) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">      middlewares[i](<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        dispatch(i + <span class="number">1</span>) <span class="comment">// 当用户调用next时会取出下一个继续执行</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>compose执行时会先通过<code>dispatch(0)</code>执行middlewares的第一个函数，传入<code>()=&gt;&#123;dispatch(1)&#125;</code>作为next。中间件1运行到next时会触发<code>dispatch(1)</code>的执行。<code>dispatch(1)</code>则会执行中间件2，并且传入<code>()=&gt;&#123;dispatch(2)&#125;</code>作为next。中间件2执行到next()时相当于执行<code>dispatch(2)</code>，从而触发中间件3执行…<br>具体的执行过程可以下载 👉 <a href="https://github.com/kinyaying/koa-demo/blob/main/compose.js">compose精简版</a>，看简化版compose的运行结果。</p>
<h1 id="koa上下文-ctx"><a href="#koa上下文-ctx" class="headerlink" title="koa上下文(ctx)"></a>koa上下文(ctx)</h1><p>koa中使用的环境变量是ctx。通过<code>Object.keys(ctx)</code>可知ctx上有 <code>request, response, app, req,  res, originalUrl, state</code>这几个属性。其中ctx.res, ctx.req是原生的请求和响应；ctx.response，ctx.request是针对原生请求的扩展。</p>
<p>koa要保证不同请求的ctx保持独立，并且将ctx的属性获取代理到response.js和request.js上，简化ctx取值操作。</p>
<p><strong>1. koa的context实现了不同应用以及不同请求之间的环境隔离</strong><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0018165c33749e3a9412d1ebdf3b433~tplv-k3u1fbpfcp-watermark.image"></p>
<p>如图所示：</p>
<p>① 每个koa应用都会拥有自己的context, (源码：<a href="https://github.com/koajs/koa/blob/master/lib/application.js">koa/application.js</a> 59行) 实现应用的隔离。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b706081401b149a081e7d09ecc9986ef~tplv-k3u1fbpfcp-watermark.image"></p>
<p>② 每个请求都会通过Object.create()拥有自己的ctx, (源码：<a href="https://github.com/koajs/koa/blob/master/lib/application.js">koa/application.js</a> 178行) 实现请求的隔离。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8601ffa627734426a11353ceaac7b764~tplv-k3u1fbpfcp-watermark.image"></p>
<p>通过两次的<code>Object.create</code> koa确保每次请求都能拥有独立的ctx变量，避免不同请求的ctx变量互相污染。</p>
<p><strong>2. ctx能直接取request或response的值，因为ctx被代理到request.js和response.js上，这给开发带来了便利。</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cced934c28374cc4b84c436a41cb5d7d~tplv-k3u1fbpfcp-watermark.image"></p>
<p>我们在编码时可以直接写<code>ctx.path</code>来获取当前请求的路径，这是原生的req不提供的。当从ctx上取属性path时，因为ctx被做了代理，实际上是从<code>cxt.request</code>上取path的（如图上步骤①，对应源码 <a href="https://github.com/koajs/koa/blob/master/lib/context.js">koa/context.js</a>  253行）。而<code>cxt.request</code>是request.js提供的（如图上步骤②， 对应源码  <a href="https://github.com/koajs/koa/blob/master/lib/application.js">koa/application.js</a> 179行），它能通过<code>this.req</code>获取到原生req（源码 <a href="https://github.com/koajs/koa/blob/master/lib/application.js">koa/application.js</a> 182行），然后经过解析处理转化成url返回给 <code>ctx.path</code>。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc0ca7edb85647ca93ca0f460fc27c29~tplv-k3u1fbpfcp-watermark.image"></p>
<p>再举一个例子，当我们写入<code>ctx.body=&#39;ok&#39;</code>时，实际上ctx被代理到<code>ctx.response</code>上，在response.js内通过<code>set body()</code>写入this._body变量。当返回请求时，通过<code>get body()</code>获取并返回this._body。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/879aafcdeb774e48b94b27ac97322fe0~tplv-k3u1fbpfcp-watermark.image"></p>
<p><strong>小结：</strong> koa将context上的属性代理到request.js和response.js上，通过属性劫持给context扩展了一些新的属性和方法。(源码<a href="https://github.com/koajs/koa/blob/master/lib/context.js">koa/context.js</a> 199-251行)。我们可以直接从ctx上获取对应的属性和方法，给代码的编写提供了便利。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>希望读完这篇文章能够让你对koa的实现原理有进一步的了解。koa短小精简的代码非常适合阅读。这篇文章主要介绍了：</p>
<ol>
<li>koa中间件实现使用了洋葱模型。</li>
<li>koa每次请求都会创建一个新的请求上下文，保证了context的请求隔离和应用隔离。</li>
<li>koa将context上的属性代理给response.js和request.js处理，扩展了context功能。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://koa.bootcss.com/">koa官网</a></p>
<p><a href="https://github.com/koajs/koa">koa源码</a></p>
<p><a href="https://github.com/koajs/compose">koa-compose源码</a></p>
<p><a href="https://segmentfault.com/a/1190000019603834">Koa源码浅析</a></p>
<p>—</p>
<p>希望这篇文章能够给你有所帮助，对文章中的内容有疑问的地方欢迎一起探讨。</p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>有限状态机实现JSX词法分析</title>
    <url>/2021/02/09/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0JSX%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>词法分析和语法分析是代码中非常底层的知识，在代码的编译、构建的过程中扮演了重要的角色。<br>词法分析是指把代码片段逐个单词的读取，根据分词规则转化成一个个 token。每个 token 有对这段单词的类型和内容进行描述。最后将这些 token 收集成 tokens 返回回来。目前常用的 jsx 词法解析器是<a href="https://github.com/jquery/esprima/blob/master/src/jsx-parser.ts">esprima</a> 。</p>
<p>为了掌握 jsx 词法解析，我也实现了简易版的 jsx 词法解析器。</p>
<p><strong>代码仓库：<a href="https://github.com/kinyaying/tokenizer">jsx-tokenizer</a></strong></p>
<p><strong>npm: <a href="https://www.npmjs.com/package/jsx-tokenizer">jsx-tokenizer</a></strong></p>
<span id="more"></span>

<h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><p>有限状态机，（英语：Finite-state machine, FSM），又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。</p>
<p>状态机有以下特点：</p>
<ul>
<li>每一个状态都是一个机器,每个机器都可以接收输入和计算输出</li>
<li>机器本身没有状态,每一个机器会根据输入决定下一个状态</li>
</ul>
<h5 id="优点：在状态比较多的情况下，把状态、事件及-transition-集中到一个状态机中，进行统一管理。这样不需要写太多的-if-else，或者-case-判断，如果增加状态和事件，也便于代码的维护和扩展。"><a href="#优点：在状态比较多的情况下，把状态、事件及-transition-集中到一个状态机中，进行统一管理。这样不需要写太多的-if-else，或者-case-判断，如果增加状态和事件，也便于代码的维护和扩展。" class="headerlink" title="优点：在状态比较多的情况下，把状态、事件及 transition 集中到一个状态机中，进行统一管理。这样不需要写太多的 if-else，或者 case 判断，如果增加状态和事件，也便于代码的维护和扩展。"></a>优点：在状态比较多的情况下，把状态、事件及 transition 集中到一个状态机中，进行统一管理。这样不需要写太多的 if-else，或者 case 判断，如果增加状态和事件，也便于代码的维护和扩展。</h5><h3 id="JSX-词法分析"><a href="#JSX-词法分析" class="headerlink" title="JSX 词法分析"></a>JSX 词法分析</h3><p>词法分析概念：接收原始代码,然后把它分割成一些被称为  token  的东西，这个过程是在词法分析器(Tokenizer 或者 Lexer)中完成的。</p>
<p>目前常用的库有：<a href="https://github.com/jquery/esprima/blob/master/src/jsx-parser.ts">esprima</a> ，可以将 JSX 语法转换成抽象语法树。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> esprima = <span class="built_in">require</span>(<span class="string">&#x27;esprima&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> sourceCode = <span class="string">&#x27;let dom = &lt;h1&gt;hello world&lt;/h1&gt;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> ast = esprima.parseModule(sourceCode, &#123; <span class="attr">jsx</span>: <span class="literal">true</span>, <span class="attr">tokens</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>上代码的运行结果如下，例如：<code>let dom = &lt;h1&gt;hello world&lt;/h1&gt;</code> 这个代码片段被分割成 tokens 里的片段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Module &#123;</span><br><span class="line">  type: &#39;Program&#39;,</span><br><span class="line">  body: [</span><br><span class="line">    VariableDeclaration &#123;</span><br><span class="line">      type: &#39;VariableDeclaration&#39;,</span><br><span class="line">      declarations: [Array],</span><br><span class="line">      kind: &#39;let&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  sourceType: &#39;module&#39;,</span><br><span class="line">  tokens: [</span><br><span class="line">    &#123; type: &#39;Keyword&#39;, value: &#39;let&#39; &#125;,</span><br><span class="line">    &#123; type: &#39;Identifier&#39;, value: &#39;dom&#39; &#125;,</span><br><span class="line">    &#123; type: &#39;Punctuator&#39;, value: &#39;&#x3D;&#39; &#125;,</span><br><span class="line">    &#123; type: &#39;Punctuator&#39;, value: &#39;&lt;&#39; &#125;,</span><br><span class="line">    &#123; type: &#39;JSXIdentifier&#39;, value: &#39;h1&#39; &#125;,</span><br><span class="line">    &#123; type: &#39;Punctuator&#39;, value: &#39;&gt;&#39; &#125;,</span><br><span class="line">    &#123; type: &#39;JSXText&#39;, value: &#39;hello world&#39; &#125;,</span><br><span class="line">    &#123; type: &#39;Punctuator&#39;, value: &#39;&lt;&#39; &#125;,</span><br><span class="line">    &#123; type: &#39;Punctuator&#39;, value: &#39;&#x2F;&#39; &#125;,</span><br><span class="line">    &#123; type: &#39;JSXIdentifier&#39;, value: &#39;h1&#39; &#125;,</span><br><span class="line">    &#123; type: &#39;Punctuator&#39;, value: &#39;&gt;&#39; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>esprima 内部就是使用了有限状态机的思想，逐步分析 jsx 语句中的每个字符，并将结果组装成对应的 node，收集到 tokens 里。</p>
<h3 id="自己实现-JSX-词法解析"><a href="#自己实现-JSX-词法解析" class="headerlink" title="自己实现 JSX 词法解析"></a>自己实现 JSX 词法解析</h3><p>我们也可以自己实现词法解析，将 jsx 语句转换成 tokens。我自己写的方法和 esprima 相比扩展性稍弱，且考虑的场景也相对简单，便于让人理解状态机模式以及使用在词法分析场景下的应用。</p>
<p>举个例子，处理 sourceCode=’<span>hello</span>‘这段代码，会依次识别每个字符，根据当前字符推断下一个运行的函数是什么。流程图如下：</p>
<p><img src="//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd999474d88347328df7847637ddc275~tplv-k3u1fbpfcp-zoom-1.image" alt="图1. 词法解析流程图"></p>
<p>我将写的<a href="https://www.npmjs.com/package/jsx-tokenizer">jsx-tokenizer</a>放到了 npm 上，可以 down 下来跑一下；也可以在<a href="https://github.com/kinyaying/tokenizer">github 仓库</a>里查看。</p>
<p><strong>使用步骤：</strong></p>
<ol>
<li>安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i jsx-tokenizer</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; tokenizer &#125; = <span class="built_in">require</span>(<span class="string">&#x27;jsx-tokenizer&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> sourceCode =</span><br><span class="line">  <span class="string">&#x27;&lt;h1 id=&quot;title&quot; style=&quot;background: green;&quot;&gt;&lt;span&gt;hello&lt;/span&gt;world&lt;/h1&gt;&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;tokenizer词法解析结果:&#x27;</span>, tokenizer(sourceCode))</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化管理github博客——shero-cli</title>
    <url>/2021/02/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AE%A1%E7%90%86github%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94shero-cli/</url>
    <content><![CDATA[<h1 id="shero-cli-是什么？"><a href="#shero-cli-是什么？" class="headerlink" title="shero-cli 是什么？"></a>shero-cli 是什么？</h1><p>很多程序员平时喜欢使用 git 的 issue 来编写博客，因为 issue 里的 comment 部分能够提供一个作者和读者之间沟通讨论的平台。但是使用 issue 编写博客的话，涉及到博客内容和 issue 直接的关系需要维护，作者需要自己维护一个博客仓库，然后在博客完成后再复制到 issue。<br>为了让利用 github 的 issue 来开发博客变得更加愉快，就开发了 shero-cli 这款工具。主要提供的功能有：</p>
<ul>
<li>命令行式创建博客</li>
<li>命令行式发布博客</li>
<li>将仓库里的 md 文件生成目录列表，降低维护成本</li>
</ul>
<p>有兴趣的可进入 github 查看项目源码： <a href="https://github.com/kinyaying/git-issues-blog">shero-cli github 地址</a></p>
<span id="more"></span>

<h1 id="项目设计图"><a href="#项目设计图" class="headerlink" title="项目设计图"></a>项目设计图</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee03b844f30f41c49d666df27f0db6cf~tplv-k3u1fbpfcp-watermark.image"></p>
<h1 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h1><p><strong>1. shero-cli 安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install shero-cli -g</span><br></pre></td></tr></table></figure>

<p><strong>2. 进入本地的博客仓库</strong></p>
<p>因为创建博客仓库是低频操作，shero-cli 暂时不支持命令行创建 github 的博客仓库，请先在 github 上创建下。</p>
<p><strong>3. shero-cli 初始化</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shero-cli init</span><br></pre></td></tr></table></figure>

<p>需要根据提示输入用户名(github 的用户名)，仓库名(博客的仓库名)和 token。<br>由于 shero-cli 需要去创建 github 仓库的 issue，需要 token 才能有权限。token 的获取方式如下：<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82e6e5f5a19744f988c22040ef971b1b~tplv-k3u1fbpfcp-watermark.image"><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6ba08a83ec743d79de3f757fdacecd4~tplv-k3u1fbpfcp-watermark.image"><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ec710822d3849aaace66639cb45bd19~tplv-k3u1fbpfcp-watermark.image"><br>这个 token 只会出现一次,请点击复制保存下来.</p>
<p>想了解 token 更多的内容可以参考这篇文章<a href="https://dev.to/gr2m/github-api-authentication-personal-access-tokens-53kd">关于获取 git 的 token</a>。</p>
<p><strong>4. 创建一篇博客</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shero-cli create &lt;blogName&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意 blogName 就是博客名称，也会作为 issue 的标题展示</li>
<li>blogName 是必填项，.md 后缀可不填，默认生成 md 文件</li>
</ul>
<p><strong>5. 发布或更新一篇博客</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shero-cli publish &lt;blogName&gt;</span><br></pre></td></tr></table></figure>

<p><strong>shero-cli</strong>自动识别 publish 的博客对应的 issue 是否存在，存在的话就是更新 issue，不存在就新建 issue。</p>
<h1 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO list"></a>TODO list</h1><p>这个工具我是先开发一个版本，有的功能还要继续的新增和完善。也欢迎 rd 朋友提出自己的想法和建议，甚至参与到这个工具的开发中。</p>
<ul>
<li><input disabled="" type="checkbox"> shero-cli close [blogName] (issue 的关闭)</li>
<li><input disabled="" type="checkbox"> shero-cli delete [blogName] (博客的删除)</li>
<li><input disabled="" type="checkbox"> 支持博客头部和尾部使用模板</li>
<li><input disabled="" type="checkbox"> 支持博客分类</li>
<li><input disabled="" type="checkbox"> 探索打通掘金，简书等博客平台，实现一键 publish</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback">nodejs api 官网</a></p>
<p><a href="https://dev.to/gr2m/github-api-authentication-personal-access-tokens-53kd">关于获取 git 的 token</a></p>
<p>封装好了的 github api 库：<a href="https://octokit.github.io/rest.js/v18#issues-create">octokit</a></p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>解析 Vue3.0 的 dom-diff 核心算法——最长递增子序列</title>
    <url>/2021/02/09/%E8%A7%A3%E6%9E%90Vue3.0%E7%9A%84dom-diff%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="一、基础背景"><a href="#一、基础背景" class="headerlink" title="一、基础背景"></a>一、基础背景</h1><p>去年 Vue3.0 正式版本推出，受到很多人的追捧。vue3.0 中也对 dom-diff 算法进行了优化，其中就用到了 <strong>「最长递增子序列」</strong>。</p>
<p>先简要介绍下基础背景。我们在 vue 开发项目的时候，常用模板或者 jsx 语法来编写 DOM。实际上我们编写的代码会被<code>@vue/compiler-dom</code>转化为虚拟 DOM 节点，即 Virtual DOM，之后再将虚拟 DOM 节点渲染成实际的 DOM 节点，Virtual DOM 也会被组织成树形结构，即 Virtual DOM 树。类似如下所示 👇🏽：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78240500087d4536b74286e30aff5b4c~tplv-k3u1fbpfcp-watermark.image"></p>
<span id="more"></span>

<p>也许你会有个问题，为什么要引入虚拟 DOM，而不是直接把组件转换成正式 DOM 节点呢？在我看来有两个优点：</p>
<ol>
<li><strong>更高效：</strong> 当组件发生变化时，利用虚拟 DOM 树可以对新旧 DOM 进行比较，找出区别，只更新发生变化的 DOM，让渲染更加高效。</li>
<li><strong>更灵活：</strong> 将原来直接渲染变成先构建虚拟 DOM，再进行渲染。相当于抽离出中间层，对应的渲染层可以是针对浏览器的渲染，也可以是针对小程序等其他平台的渲染。</li>
</ol>
<p>根据上面的介绍，我们知道 Vue 会把我们编写的组件转换成虚拟 DOM 树，并且将虚拟 DOM 树进行比较后再根据变化情况更新真实 DOM。比如原有列表为 <code>[a, b, c, d, e, f]</code> ，而新列表为 <code>[a, d, b, c, e, f]</code>， 这时会这样进行 diff：</p>
<ol>
<li><p><strong>去除相同前置和后置元素</strong> ，此优化由 <a href="https://neil.fraser.name/writing/diff/">Neil Fraser</a> 提出，可以比较容易实现而且带来带来比较明显的提升；</p>
<p>比如针对上情况，去除相同的前置和后置元素后，真正需要处理的是 <code>[ b, c, d]</code> 和 <code>[d, b, c]</code> ，复杂性会大大降低。</p>
</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64b6fce49042461b9c75213ed74f1dd5~tplv-k3u1fbpfcp-watermark.image"></p>
<ol start="2">
<li><p><strong>最长递增子序列</strong></p>
<p>接着要将原数组中的<code>[ b, c, d]</code> 转化成 <code>[d, b, c]</code> 。Vue3 中对移动次数进行了进一步的优化。下面对这个算法进行介绍：</p>
<ol>
<li><p>首先遍历新列表，通过 key 去查找在原有列表中的位置，从而得到新列表在原有列表中位置所构成的数组。比如原数组中的<code>[ b, c, d]</code>， 新数组为 <code>[d, b, c]</code> ，得到的位置数组为 <code>[3, 1, 2]</code> ，现在的算法就是通过位置数组判断最小化移动次数；</p>
</li>
<li><p>计算最长递增子序列</p>
<p>最长递增子序列是经典的动态规划算法，不了解的可以前往 <a href="https://baike.baidu.com/item/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/22828111#1">最长递增子序列</a> 去补充一下前序知识。那么为什么最长递增子序列就可以保证移动次数最少呢？因为在位置数组中递增就能保证在旧数组中的相对位置的有序性，从而不需要移动，因此递增子序列的最长可以保证移动次数的最少</p>
<p>对于前面的得到的位置数组<code>[3, 1, 2]</code>，得到最长递增子序列 <code>[1, 2]</code> ，在子序列内的元素不移动，不在此子序列的元素移动即可。对应的实际的节点即 <code>d</code> 节点移动至<code>b, c</code>前面即可。</p>
</li>
</ol>
</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef1b8d1d19d1489fb0c50dbbed2dabfb~tplv-k3u1fbpfcp-watermark.image"></p>
<p>本文就将介绍最长递增子序列的算法。大家可以配合着 Vue3 中的源码来阅读，希望读完这篇文章后能够更加理解 Vue3 中关于最长递增子序列的实现。</p>
<p>Vue3.0 的源码 👉：<a href="https://github.com/vuejs/vue-next/blob/540e26f49c09edf09b6a60ac2a978fdec52686bf/packages/runtime-core/src/renderer.ts">vue-next/renderer.ts</a> 请阅读其中的<code>getSequence</code>方法。</p>
<p>力扣上没有完全一样的题目，有一道最接近的题 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a> ，它的要求是求最长递增子序列的长度，我们可以把题目换成求最长递增子序列的索引。</p>
<h1 id="二、题目描述："><a href="#二、题目描述：" class="headerlink" title="二、题目描述："></a>二、题目描述：</h1><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：[ 2, 4, 5, 7 ]<br>解释：最长递增子序列是 [2,3,7,18]，因此索引是[ 2, 4, 5, 7 ]。</p>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8fe1a74e0934fc1b8a83d2416ce866d~tplv-k3u1fbpfcp-watermark.image"></p>
<p>这里再强调一遍，我们要求的是最长子序列对应的索引。</p>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：nums = [0,1,0,3,2,3]<br>输出：[ 0, 1, 4, 5 ]</p>
<p>解释：最长递增子序列是 [0,1,2,3]，因此索引是[ 0,1,4,5 ]。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：nums = [7,7,7,7,7,7,7]<br>输出：[0]</p>
<p>解释：最长递增子序列是 [7]，因此索引是[0]。</p>
</blockquote>
<p>敲黑板，👩‍🏫，我们要求的是最长递增子序列的索引。ok，强调完了，开始解题吧。</p>
<h1 id="三、思路分析："><a href="#三、思路分析：" class="headerlink" title="三、思路分析："></a>三、思路分析：</h1><p>假设我们要实现 getSequence 方法，入参是 nums 数组，返回结果是一个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getSequence = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// your code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤 1. 先创建一个空数组 result 保存索引。遍历 nums，将当前项<code>current</code>和 result 的最后一项对应的值<code>last</code>进行比较。如果当前项大于最后一项，直接往 result 中新增一项；否则，针对 result 数组进行二分查找，找到并替换比当前项大的那项。下图示意图中为了方便理解 result 存放的是 nums 中的值，实际代码存放的是数组索引。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daa7150e1a3040ad8359112ae01fa23f~tplv-k3u1fbpfcp-watermark.image"><br>步骤 2. 这步是难点，因为步骤 1 在替换的过程中<code>贪心</code>了，导致最后的结果错乱。</p>
<p>为了解决这个问题，使用的<code>前驱节点</code>的概念，需要再创建一个数组 preIndexArr。在步骤 1 往 result 中新增或者替换新值的时候，同时 preIndexArr 新增一项，该项为当前项对应的前一项的索引。这样我们有了两个数组：</p>
<ul>
<li><p>result：[1,3,4,6,7,9]</p>
</li>
<li><p>preIndexArr：[undefined,0,undefined,1,3,4,4,6,1]</p>
</li>
</ul>
<p>result 的结果是不准确的，但是 result 的最后一项是正确的，因为最后一项是最大的，最大的不会算错。我们可知最大一项是值 9，索引是 7。可查询<code>preIndexArr[7]</code>获得 9 的前一项的索引为 6，值为 7…依次类推能够重建新的 result。</p>
<p>注意：下图中为了方便理解，result 存放的是值，实际代码中存放的是索引。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/784259c30746464c98481a9270350fa6~tplv-k3u1fbpfcp-watermark.image"><br>ok，思路说完了，那么下面就开始码代码了 🧑‍💻</p>
<h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getSequence1 = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> last = nums[result[result.length - <span class="number">1</span>]],</span><br><span class="line">      current = nums[i]</span><br><span class="line">    <span class="keyword">if</span> (current &gt; last || last === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 当前项大于最后一项</span></span><br><span class="line">      result.push(i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当前项小于最后一项，二分查找+替换</span></span><br><span class="line">      <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">        end = result.length - <span class="number">1</span>,</span><br><span class="line">        middle</span><br><span class="line">      <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        middle = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (nums[result[middle]] &gt; current) &#123;</span><br><span class="line">          end = middle</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          start = middle + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      result[start] = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getSequence = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [],</span><br><span class="line">    preIndex = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> last = nums[result[result.length - <span class="number">1</span>]],</span><br><span class="line">      current = nums[i]</span><br><span class="line">    <span class="keyword">if</span> (current &gt; last || last === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// 当前项大于最后一项</span></span><br><span class="line">      preIndex[i] = result[result.length - <span class="number">1</span>]</span><br><span class="line">      result.push(i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当前项小于最后一项，二分查找+替换</span></span><br><span class="line">      <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">        end = result.length - <span class="number">1</span>,</span><br><span class="line">        middle</span><br><span class="line">      <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="comment">// 重合就说明找到了 对应的值,时间复杂度O(logn)</span></span><br><span class="line">        middle = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>) <span class="comment">// 找到中间位置的前一个</span></span><br><span class="line">        <span class="keyword">if</span> (nums[result[middle]] &gt; current) &#123;</span><br><span class="line">          end = middle</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          start = middle + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果相同 或者 比当前的还大就不换了</span></span><br><span class="line">      <span class="keyword">if</span> (current &lt; nums[result[start]]) &#123;</span><br><span class="line">        preIndex[i] = result[start - <span class="number">1</span>] <span class="comment">// 要将他替换的前一个记住</span></span><br><span class="line">        result[start] = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 利用前驱节点重新计算result</span></span><br><span class="line">  <span class="keyword">let</span> length = result.length, <span class="comment">//总长度</span></span><br><span class="line">    prev = result[length - <span class="number">1</span>] <span class="comment">// 最后一项</span></span><br><span class="line">  <span class="keyword">while</span> (length-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据前驱节点一个个向前查找</span></span><br><span class="line">    result[length] = prev</span><br><span class="line">    prev = preIndex[result[length]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<ul>
<li><p>本题目用到的核心思想有：贪心，二分查找，前驱节点</p>
</li>
<li><p>这个题解的时间复杂度为<code>O(nlogn)</code>，即 for 循环的<code>n</code>乘以二分查找的<code>logn</code></p>
</li>
</ul>
<h1 id="四、完整代码："><a href="#四、完整代码：" class="headerlink" title="四、完整代码："></a>四、完整代码：</h1><p>在 <strong>三、思路分析</strong>的步骤 2 已给出完整代码</p>
<h1 id="五、总结："><a href="#五、总结：" class="headerlink" title="五、总结："></a>五、总结：</h1><p>本文介绍了<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>的其中一种解题思路，核心思想用到了<strong>贪心，二分查找和前驱节点</strong>。</p>
<p>vue3.0 中核心 dom-diff 算法用到了最长递增子序列，学习掌握此题的解法有助于我们更好的了解 vue3.0 的 dom-diff。</p>
<p>感谢阅读~</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>开发油猴脚手架wokoo复盘</title>
    <url>/2021/02/12/%E5%BC%80%E5%8F%91%E6%B2%B9%E7%8C%B4%E6%8F%92%E4%BB%B6%E8%84%9A%E6%89%8B%E6%9E%B6Wokoo%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<h1 id="一、项目简介："><a href="#一、项目简介：" class="headerlink" title="一、项目简介："></a>一、项目简介：</h1><p>这篇文件介绍的是油猴插件脚手架Wokoo的开发过程与复盘。Wokoo是我开发的脚手架，用来快速起一个基础项目用于<code>油猴插件</code>的开发。</p>
<ol>
<li>Wokoo的npm地址：<a href="https://www.npmjs.com/package/wokoo">wokoo</a></li>
<li>Wokoo的github地址：<a href="https://github.com/kinyaying/wokoo">wokoo</a>  (如果觉得不错，请点小星星)</li>
<li>Wokoo脚手架开发的油猴插件有：<ul>
<li><a href="https://greasyfork.org/zh-CN/scripts/421238-zhihu-helper">知乎目录</a></li>
<li><a href="https://greasyfork.org/zh-CN/scripts/421189-movesearch">划词搜索</a></li>
</ul>
</li>
<li>Wokoo使用说明文档 👉 <a href="https://juejin.cn/post/6922815205575491597">5分钟上手开发浏览器插件——油猴脚手架wokoo(使用篇)</a></li>
<li>不了解什么是油猴插件？戳这里 👉  <a href="https://zhuanlan.zhihu.com/p/99390731">Chrome 插件大杀器：「油猴」Tampermonkey 使用详解</a></li>
</ol>
<p>在这个项目中我扮演了项目的<code>产品经理</code>，<code>开发主R</code>，<code>运营官</code> 这几个角色。从头到尾负责开发一个开源项目，让我有了满满的成就感。</p>
<span id="more"></span>
<p>回想当初想做Wokoo脚手架的初衷，只是因为自己想写一个油猴插件，发现比较麻烦，自己也趟了一些坑。我就觉得写一个脚手架，能够一键生成基础的油猴项目很有意义。完成Wokoo脚手架的开发后，我在某技术群中分享了这篇文章，被该圈里的大佬邀请做一次分享。于是我又增加了<a href="https://juejin.cn/post/6925605904561750030">使用Wokoo进行项目实战的案例</a>。然后又指导群里成员完成从零上手，实现一个油猴插件的开发。</p>
<p>整个过程在当初只是一个小小的idea，在逐步升级打怪的过程中，我把当初的小想法变成了一个正式的开源项目。这次经历让我得到很多成长，包括技术、沟通、合作等方面。感谢这次经历~ 🎉</p>
<h1 id="二、项目背景："><a href="#二、项目背景：" class="headerlink" title="二、项目背景："></a>二、项目背景：</h1><h2 id="开发Wokoo脚手架初衷"><a href="#开发Wokoo脚手架初衷" class="headerlink" title="开发Wokoo脚手架初衷"></a>开发Wokoo脚手架初衷</h2><p>一开始我想做一个给团队内部使用的浏览器插件。进行技术选型时发现开发油猴插件开发最省时省力，而且不用审核上线迅速，是最佳选择。</p>
<p>开发过程遇到一些坑：</p>
<ol>
<li><p>油猴插件本质上是嵌入一段js代码到当前html中。所以很多油猴插件都直接使用jQuery进行开发。这对于我们习惯使用了Vue、React等框架的rd来说会不适应，尤其是插件涉及到页面组件开发，使用jQuery有点痛苦。<strong>这就是第一个痛点：要配置vue或react基础项目</strong></p>
</li>
<li><p>所以我就考虑用vue-cli起一个vue项目来完成插件开发。项目创建完成后，我又发现要配置油猴脚本。下面这个编辑器里的代码就是要配置的油猴脚本，里面的注释都是有含义的，比如<code>@match</code>  指定某些域名下开启此插件，<code>// @match http://*/*</code>  表示只能在http协议的网页中使用。默认配置的就是http协议，但是现在的网页都升级到https了，如果不修改此条配置，你会发现插件根本跑不起来。👇</p>
</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546d2d1512d04635b77e4db04d267ad4~tplv-k3u1fbpfcp-watermark.image" alt="屏幕快照 2021-03-15 下午9.30.21.png"></p>
<p>   <strong>第二个痛点：要阅读油猴脚本的文档，理解里面的注释内容</strong></p>
<ol start="3">
<li>使用vue开发的项目能够通过<code>localhost:8080</code>访问，但是怎么把项目和油猴插件结合起来，实现一边开发项目，一边实时调试插件？总不能一边开发，一边<code>npm run build</code>构建出包，再把构建结果复制到油猴插件的编辑器中吧？<strong>第三个痛点：如何实现边开发边展示插件效果？</strong></li>
</ol>
<h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>总结下，我想实现一个针对开发油猴插件的脚手架，满足如下功能：</p>
<ol>
<li>输入一个命令行生成一个基础项目</li>
<li>项目中包含基础的油猴脚本配置</li>
<li>提供方案，让油猴插件能边开发，边调试</li>
</ol>
<h2 id="解决的痛点"><a href="#解决的痛点" class="headerlink" title="解决的痛点"></a>解决的痛点</h2><p>wokoo脚手架就是为了满足上业务场景，解决我在开发油猴插件时遇到的3个痛点。</p>
<ol>
<li><p>一键式创建基础的油猴插件项目，可选模板有:</p>
<p>[ ] vue</p>
<p>[ ] react</p>
</li>
</ol>
<ol start="2">
<li><p>基础项目中的tampermonkey.js文件中满足油猴插件的基础配置，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         my-plugin</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.0.1</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author</span></span><br><span class="line"><span class="comment">// @match        https://*/*</span></span><br><span class="line"><span class="comment">// @match        http://*/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (location.href === <span class="string">&#x27;http://localhost:8080/&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.src = <span class="string">&#x27;http://localhost:8080/app.bundle.js&#x27;</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>开发者直接复制这段代码到油猴插件编辑器就行，解决上面的第二个痛点。</p>
<p>当然开发者在开发过程中是要做到阅读 <a href="https://www.tampermonkey.net/documentation.php?version=4.6&ext=dhdg">tampermonkey官网文档 </a>的，wokoo脚手架提供的基础文档配置，目的是降低油猴插件的开发难度。</p>
</li>
<li><p>tampermonkey.js中写的js脚本，将油猴插件加载的js文件打到本地用webpack起的服务上，实现边开发边调试。解决上面的第三个痛点。</p>
</li>
</ol>
<h1 id="三、实践过程："><a href="#三、实践过程：" class="headerlink" title="三、实践过程："></a>三、实践过程：</h1><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul>
<li>参考了<a href="https://github.com/facebook/create-react-app">create-react-app</a>的设计思路，将<code>wokoo-scripts</code>和<code>wokoo-template</code>部分解耦，拆分成两个包单独管理，有利于未来的功能拓展。比如未来要新增一个模板是基于jquery的，只需要拓展wokoo-template部分即可。</li>
<li>monorepo方案管理代码，使用lerna进行包管理。</li>
</ul>
<h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><p>这张图是Wokoo的架构设计图，Wokoo使用monorepo方案管理代码，在一个git仓库中维护<code>wokoo-scripts</code>和<code>wokoo-template</code>两个模块。使用lerna进行包管理。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf77f0701b274c7483a0d6aaba207640~tplv-k3u1fbpfcp-watermark.image?imageslim"></p>
<h2 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h2><p>我要实现的功能如下：</p>
<ol>
<li><p>安装wokoo，执行<code>npm i wokoo -g</code>后在npm的全局目录下安装wokoo</p>
</li>
<li><p>执行命令<code>wokoo my-app</code>，弹出要求用户选择模板的提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? which template do you prefer? (Use arrow keys)</span><br><span class="line">❯ vue</span><br><span class="line">  react</span><br></pre></td></tr></table></figure></li>
<li><p>选择模板后，创建一个基础项目，项目内容包括：1. 配置好的vue或react项目，2. <code>tampermonkey.js</code> 文件，内部是配置好的基础油猴脚本。</p>
</li>
</ol>
<p>模仿<a href="https://github.com/facebook/create-react-app">cra</a>的实现思路，我将wokoo拆分成两个部分，<code>wokoo-scripts</code>和<code>wokoo-template</code>。</p>
<ul>
<li><code>wokoo-scripts</code>负责命令行的交互，从npm上拉取<code>wokoo-template</code>到生成的基础项目my-app中。</li>
<li><code>wokoo-template</code>提供两套模板，分别是轻量级配置的vue和react基础项目。还提供<code>tampermonkey.js</code> 文件</li>
</ul>
<p>整个项目的工作流入下👇：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/666e725ea331445387a7f8ac8f76b106~tplv-k3u1fbpfcp-watermark.image"></p>
<h3 id="wokoo-scripts"><a href="#wokoo-scripts" class="headerlink" title="wokoo-scripts"></a>wokoo-scripts</h3><p>目录介绍：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── bin</span><br><span class="line">│   └── www    					提供给npm的入口文件</span><br><span class="line">├── index.js						主程序，提供命令行交互功能</span><br><span class="line">├── modifyTemplate.js 	替换模板中的ejs语法</span><br><span class="line">├── package-lock.json</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>

<p>代码流程图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6b207eeeac1459889c3094468bc0892~tplv-k3u1fbpfcp-watermark.image" alt="流程图.png"></p>
<p>图中介绍了<code>wokoo-scripts</code>各个方法的调用顺序： init -&gt; createApp -&gt;run-&gt;modifyTemplate。以及各方法实现的功能。</p>
<h3 id="wokoo-template"><a href="#wokoo-template" class="headerlink" title="wokoo-template"></a>wokoo-template</h3><p>目录介绍：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── icon.jpg</span><br><span class="line">│   └── index.html							html文件</span><br><span class="line">├── react-template							react模板路径</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── src</span><br><span class="line">│   │   ├── app.js							</span><br><span class="line">│   │   ├── app.less</span><br><span class="line">│   │   └── index.js						入口文件</span><br><span class="line">│   ├── tampermonkey.js					油猴脚本配置</span><br><span class="line">│   ├── template.json						react中依赖的库文件</span><br><span class="line">│   └── webpack.config.base.js	对应react项目的webpack配置</span><br><span class="line">├── vue-template								和react的项目结构类似</span><br><span class="line">│   ├── ...				</span><br><span class="line">└── webpack.config.js						公共的webpack配置</span><br></pre></td></tr></table></figure>

<p><code>wokoo-template</code>提供基础项目的模板：</p>
<ul>
<li><p>分为vue-template和react-template</p>
</li>
<li><p>vue-template和react-template分别对应webpack配置的一个vue或react基础项目</p>
</li>
<li><p>使用ejs模板，实现wokoo-scripts注入变量</p>
</li>
<li><p>tampermonkey.js 文件是油猴插件的配置文件，需要将此文件内的代码复制到油猴插件的编辑框中。如下是tampermonkey.js文件的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         &lt;%=projectName%&gt;</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      &lt;%=version%&gt;</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author</span></span><br><span class="line"><span class="comment">// @match        https://*/*</span></span><br><span class="line"><span class="comment">// @match        http://*/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (location.href === <span class="string">&#x27;http://localhost:8080/&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.src = <span class="string">&#x27;http://localhost:8080/app.bundle.js&#x27;</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>此文件中被注释掉的<code>//@xxx </code>都有含义，可以对应着 <a href="https://www.tampermonkey.net/documentation.php?version=4.6&ext=dhdg">tampermonkey开发文档 </a> 理解。</p>
<ul>
<li><p><code>@name</code>  脚本的名字，最后会被替换成项目名</p>
</li>
<li><p><code>@namespace</code> 可以写自己的域名,当自己把脚本分享后,用户可以直接通过这儿找到你的具体功能实现</p>
</li>
<li><p><code>@description</code>  插件描述</p>
</li>
<li><p><code>@match</code>  指定某些域名下开启此插件，默认配了两条，<code>// @match        https://*/*</code>和<code>// @match        https://*/*</code>  表示在所有域名下都开启。</p>
</li>
</ul>
<p>详细的开发过程可以阅读文章：<a href="https://juejin.cn/post/6925613440752943112">wokoo脚手架（搭建篇）</a></p>
<h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><ol>
<li><p>创建基础项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx wokoo my-app</span><br></pre></td></tr></table></figure></li>
<li><p>起服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></li>
<li><p>复制tampermonkey.js内容到<a href="chrome-extension://dhdgffkkebhmkfjojejmpbldmpobfkfo/options.html#url=&nav=new-user-script">油猴插件编辑器</a>，注意：要复制全部内容，包括注释部分。（此步骤默认你已经安装了油猴插件，没安装的话就安装下 👉<a href="https://chrome.google.com/webstore/detail/tampermonkey-beta/gcalenpjmijncebpfijmoaglllgpjagf?hl=zh-CN">油猴插件安装地址</a>）</p>
</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811cad2db5cb4332bfec83ea697aa2a2~tplv-k3u1fbpfcp-watermark.image" alt="屏幕快照 2021-03-15 下午9.30.21.png"></p>
<ol start="4">
<li>打开某网页，你能看到一只的猴子🐒，代表流程已跑通，你只需开发自己的业务代码即可。</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f8e6a5a044f4f2980febedf066bbcd1~tplv-k3u1fbpfcp-watermark.image" alt="demo2.gif"></p>
<h2 id="开发中遇到的问题及解决方案"><a href="#开发中遇到的问题及解决方案" class="headerlink" title="开发中遇到的问题及解决方案"></a>开发中遇到的问题及解决方案</h2><p><strong>问题1</strong></p>
<p>油猴插件的本质是往页面中注入一段js脚本，要注意避免和原始网页之间的冲突。拿知乎举例子，</p>
<ol>
<li>使用wokoo脚手架创建的项目的根节点id = root ，而知乎根节点网页中已有一个div节点id=root，命名重复了。</li>
<li>不光根节点id的命名要注意避免和宿主网页中的元素重复，还要wokoo创建的项目A和项目B的根节点id不同。因为用户可能同时使用多个油猴插件，比如「划词搜索」和「知乎目录」一起用，这就要确保两个插件的根节点id是不一样的。</li>
</ol>
<p><strong>解决方式</strong></p>
<p>将wokoo-template中的根节点根据<code>wokooApp-$&#123;项目名&#125;-$&#123;时间戳&#125;</code>的规则进行命名，避免冲突。</p>
<p><strong>问题2</strong></p>
<p>有的网页安全策略做的比较好，比如知乎使用了csp内容安全策略，阻止加载非指定域名的js脚本。</p>
<p>结合实际情况来看，比如我们已经使用wokoo初始化一个项目my-app，并完成了<a href="chrome-extension://dhdgffkkebhmkfjojejmpbldmpobfkfo/options.html#url=&nav=new-user-script">油猴脚本</a>的配置，打开知乎发现右上角没有出现猴子logo，并且控制台报错。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c6afc5b4cb4494b72c0d7b685f5579~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>再看请求的html资源的响应头，可以发现多了一条<code>content-security-policy</code>规则。也就是说知乎使用了csp内容安全策略，通过<code>content-security-policy</code>中的<code>script-src</code>字段可知，知乎只允许加载指定域名的js。具体情况可阅读 👉 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">内容安全策略( CSP )</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7ce3b03a5434e2aac0a911940d01a0d~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>而将tampermonkey.js文件拷贝到<a href="chrome-extension://dhdgffkkebhmkfjojejmpbldmpobfkfo/options.html#url=&nav=new-user-script">油猴插件编辑器</a>时，有下面一段代码👇</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (location.href === <span class="string">&#x27;http://localhost:8080/&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.src = <span class="string">&#x27;http://localhost:8080/app.bundle.js&#x27;</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为我们在调试的时候为了保证实时查看插件效果，往页面的html拼了一个js文件上去，而该文件指向webpack起的服务：<code>http://localhost:8080/app.bundle.js</code>。这不是知乎指定的域名，当然被拦截了。</p>
<p><strong>解决方式</strong></p>
<p>怎么办呢？嘿嘿，魔高一尺道高一丈，wokoo脚手架当然给出了解决方案。</p>
<ol>
<li><p>开发阶段，安装插件<a href="https://chrome.pictureknow.com/extension?id=5b80153e8db143afa59310bc0f282f1f">Disable Content-Security-Policy</a>, 在调试知乎页面时开启插件，自动把html页面的<code>content-security-policy</code>给设置为空。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba9ac0c0e6d14367bcd51b3aff3a9e2b~tplv-k3u1fbpfcp-zoom-1.image" alt="截图"></p>
</li>
<li><p>上线到<a href="https://greasyfork.org/">油猴市场</a>时，将构建后的脚本复制到油猴插件编辑器中，避免使用cdn的方式部署。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2da6218f824bc7917a43b107362899~tplv-k3u1fbpfcp-zoom-1.image" alt="zhihu-tampermonkey"></p>
</li>
</ol>
<ul>
<li><p>注意，编辑框内对代码有最大限制，如果app.bundle.js大小超过最大限制，要进行拆包处理。</p>
<p>拆包步骤：</p>
<ul>
<li><p>油猴编辑器内的配置代码，增加两行。此处我用react举例，把react通过静态资源链接的方式引入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; @require https:&#x2F;&#x2F;unpkg.com&#x2F;react@17&#x2F;umd&#x2F;react.production.min.js</span><br><span class="line">&#x2F;&#x2F; @require https:&#x2F;&#x2F;unpkg.com&#x2F;react-dom@17&#x2F;umd&#x2F;react-dom.production.min.js</span><br></pre></td></tr></table></figure></li>
<li><p>修改webpack.config.base.js的entry字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    app: &#39;&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    vendor: [</span><br><span class="line">      &#x2F;&#x2F; 将react和react-dom这些单独打包出来，减小打包文件体积</span><br><span class="line">      &#39;react&#39;,</span><br><span class="line">      &#39;react-dom&#39;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重新构建代码，把代码复制到编辑框中。</p>
</li>
</ul>
</li>
</ul>
<p>具体的wokoo使用方式我有写专门的文档：</p>
<p><a href="https://juejin.cn/post/6922815205575491597">5分钟上手开发浏览器插件——油猴脚手架wokoo(使用篇)</a></p>
<p><a href="https://juejin.cn/post/6925605904561750030/">快速上手油猴插件开发（实战篇）</a></p>
<h1 id="四、总结思考："><a href="#四、总结思考：" class="headerlink" title="四、总结思考："></a>四、总结思考：</h1><h2 id="技术上收获"><a href="#技术上收获" class="headerlink" title="技术上收获"></a>技术上收获</h2><ol>
<li>为了把脚手架写的专业一点，我去研究了create-react-app的源码，看大佬写的代码真的是佩服，自己以后在写代码时也要多考虑组织结构，逻辑解耦。</li>
<li>使用monorepo方案，一个git仓库管理多个库文件（包括<a href="https://www.npmjs.com/package/wokoo">wokoo-script</a>和<a href="https://www.npmjs.com/package/wokoon-template">wokoo-template</a>，发现真香👍。 解决了开发多个相关联的库时，需要切换不同库的仓库，代码等问题，保证工作流的连续。</li>
</ol>
<p>总之，在搞技术的道路上还是一句话：「纸上得来终觉浅，绝知此事要躬行」。</p>
<h2 id="思维上收获"><a href="#思维上收获" class="headerlink" title="思维上收获"></a>思维上收获</h2><ol>
<li><p>我意识到做一件事情，小到一次分享，一篇文章，大到一个开源项目，一个产品，最根本的出发点应该是「更好的服务产品的使用方」。只有服务好使用方，你做的事情才能发挥最大价值。</p>
<blockquote>
<p>比如当初在群里分享利用Wokoo脚手架开发插件「划词搜索」时，发现总是有人问我一些简单的问题，我当时就想文档里明明写了啊，后来再次读那段内容时，我发现我是站在开发者的角度去写文档，而没有站在使用者的角度写。</p>
</blockquote>
</li>
<li><p>任何事情，一开始看可能觉得难度巨大，但是拆解成一件件小的事情后就会觉得不是那么困难。就像<code>Wokoo脚手架</code>，也是被拆分成多个步骤完成：</p>
<ul>
<li>开发脚手架</li>
<li>编写使用文档</li>
<li>写油猴插件实战案例</li>
</ul>
<p>所以遇到事情先拆解，拆分成几个小步骤来完成。不要一看到大项目就畏难就觉得搞不定。</p>
</li>
</ol>
<h1 id="五、往期文章"><a href="#五、往期文章" class="headerlink" title="五、往期文章"></a>五、往期文章</h1><p>除了油猴脚手架wokoo，我还造了其他轮子🎉🎉：</p>
<ul>
<li><p><a href="https://juejin.cn/post/6917256394743742472">shero-cli: 自动化管理github博客</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6907563804780036104">tapable可视化工具</a></p>
</li>
</ul>
<p>欢迎大家在搞技术的路上一起升级打怪造轮子~</p>
<p>——</p>
<p>感谢你的阅读😊，希望这篇文章对你有所帮助。</p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手油猴插件开发（实战篇）</title>
    <url>/2021/02/09/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%B2%B9%E7%8C%B4%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<p>这篇文章你能够学习到：</p>
<ol>
<li>快速使用油猴插件进行浏览器插件开发</li>
<li>用 wokoo 脚手架开发 2 个有意思的插件: 划词搜索<a href="https://greasyfork.org/zh-CN/scripts/421189-movesearch">MoveSearch</a> 和 知乎目录<a href="https://greasyfork.org/zh-CN/scripts/421238-zhihu-helper">zhihu-helper</a></li>
<li>有精力的话可以继续学习<a href="https://gitee.com/zhufengpeixun/browser-plugin/blob/master/wokoo%E8%84%9A%E6%89%8B%E6%9E%B6(%E6%90%AD%E5%BB%BA%E7%AF%87).md">wokoo 脚手架的搭建</a>。</li>
</ol>
<span id="more"></span>

<h1 id="为什么要学习浏览器插件开发"><a href="#为什么要学习浏览器插件开发" class="headerlink" title="为什么要学习浏览器插件开发"></a>为什么要学习浏览器插件开发</h1><p>浏览器插件开发有的同学可能接触的不多，或者有疑问，学习开发浏览器插件有什么用呢？这里我列举一些工作中的场景：</p>
<p><strong>场景 1：</strong></p>
<p>告警平台收到某个前端项目的告警日志，为了复现定位问题，需要登录某个账号内进行查看。此时 rd 需要联系产品同学，让产品同学联系对应的用户，让用户提供账号密码给 rd。此流程很长，而且给用户造成不好的印象。而如果公司内部支持免密登录，只是需要拼接一个特定的 url，url 规则比较复杂，需要有账号 id 等信息。此时如果将拼接规则写到插件里，插件提供一个按钮就能够跳转到对应的用户账号中，是不是降低了 rd 的工作量？</p>
<p><strong>场景 2：</strong></p>
<p>当测试的同学发现问题时，需要截图，打开测试平台，填写具体的问题，提交测试报告。如果能有插件在当前页面中弹出要填写的测试表单，是不是就减少了测试同学的工作流程？</p>
<p><strong>学会了浏览器插件开发后，可以做一些工作场景相关的插件，来帮助自己以及同事提高效率。这不管是述职晋升还是跳槽换工作都会是一个加分的亮点。</strong></p>
<h1 id="正式开始插件开发"><a href="#正式开始插件开发" class="headerlink" title="正式开始插件开发"></a>正式开始插件开发</h1><h2 id="一、划词搜索-MoveSearch"><a href="#一、划词搜索-MoveSearch" class="headerlink" title="一、划词搜索 MoveSearch"></a>一、划词搜索 MoveSearch</h2><h3 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a><strong>成品展示</strong></h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4945d70b45d9414a9f7c248c90962d41~tplv-k3u1fbpfcp-watermark.image"></p>
<p>安装地址：</p>
<ol>
<li>安装<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN">油猴插件</a></li>
<li>安装<a href="https://greasyfork.org/zh-CN/scripts/421189-movesearch">MoveSearch</a></li>
</ol>
<p>代码地址：<a href="https://github.com/kinyaying/wokoo/tree/master/example/MoveSearch">wokoo/example/MoveSearch</a></p>
<h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><h3 id="1-1-项目安装-amp-初始化配置"><a href="#1-1-项目安装-amp-初始化配置" class="headerlink" title="1.1 项目安装 &amp; 初始化配置"></a>1.1 项目安装 &amp; 初始化配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i wokoo -g</span><br><span class="line">wokoo MoveSearch</span><br></pre></td></tr></table></figure>

<p>选择模板</p>
<ul>
<li><input disabled="" type="checkbox"> vue</li>
<li><input disabled="" type="checkbox"> react</li>
</ul>
<p>这里选择 react</p>
<p>安装完成后，出现安装成功的界面</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5746c0132f64f93b60a4645b7bb20c0~tplv-k3u1fbpfcp-watermark.image"></p>
<p>根据提示执行下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd MoveSearch</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<ul>
<li><p>打开油猴脚本编辑器，把 tampermonkey.js 的内容复制进去。（注意：这里是指把 tampermonkey.js 里的所有内容都复制进去，包括注释。因为此文件中被注释掉的//@xxx 都有含义，可以对应着 <a href="https://www.tampermonkey.net/documentation.php?version=4.6&ext=dhdg">tampermonkey 开发文档 </a> 理解。比如<code>@match https://</code>代表在 https 页面下才会启动插件）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00816864079341c191e3fd68512098d8~tplv-k3u1fbpfcp-watermark.image"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9869211b77f645518f7e1d3ea7a1b908~tplv-k3u1fbpfcp-watermark.image"></p>
</li>
<li><p>打开网页<a href="https://kaifa.baidu.com/searchPage?wd=%E6%B2%B9%E7%8C%B4%E6%8F%92%E4%BB%B6">开发者搜索</a>，右上角出现猴子的 logo，说明环境跑通</p>
</li>
</ul>
<h3 id="1-2-实现基本功能"><a href="#1-2-实现基本功能" class="headerlink" title="1.2 实现基本功能"></a>1.2 实现基本功能</h3><p>先整理一下思路，要实现划词搜索功能，主要实现以下步骤：</p>
<ol>
<li>监听 mouseup 事件，触发时检查是否有文字被选中，如果有则弹窗展示</li>
<li>弹窗展示前发请求到 baidu 的<a href="https://kaifa.baidu.com/rest/v1/search?query=html&pageNum=1&pageSize=10">开发者搜索</a>的接口，获取搜索内容</li>
<li>如果搜索内容不为空，将内容展示到弹窗中</li>
<li>边界检测，点击弹窗区域外的内容，弹窗关闭</li>
</ol>
<p>此处有个难点，就是 baidu 的<a href="https://kaifa.baidu.com/searchPage">开发者搜索</a>接口不允许跨域，比如在掘金的网页中去请求<a href="https://kaifa.baidu.com/rest/v1/search?query=html&pageNum=1&pageSize=10">开发者搜索</a>的接口会被拦住。为解决这个问题，我使用<a href="https://vercel.com/dashboard">vercel</a>提供的 serverless 服务做了一次代理，在代理中给响应头增加了<code>Access-Control-Allow-Origin</code>等字段，开启跨域。具体方法在<strong>1.3</strong>给出，此时我们先在<a href="https://kaifa.baidu.com/searchPage">开发者搜索</a>页面里面进行开发，先保证是同域下。</p>
<p><strong>步骤 1. 监听 mouseup 事件，触发时检查是否有文字被选中</strong></p>
<p>编辑<code>/src/app.js</code>文件，增加对 mouseup 的监听：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./app.less&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">show</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> selectionObj = <span class="built_in">window</span>.getSelection()</span><br><span class="line">      <span class="keyword">var</span> selectedText = selectionObj.toString()</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;selectedText&#x27;</span>, selectedText)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; show &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span>&#123;show ? <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Wokoo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> : null&#125;<span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 2. 弹窗展示前发请求到<a href="https://kaifa.baidu.com/rest/v1/search?query=html&pageNum=1&pageSize=10">开发者搜索</a>的接口，获取搜索内容</strong></p>
<ul>
<li>安装 axios，引入 axios</li>
<li>对 componentDidMount 内的代码进行改造，请求<a href="https://kaifa.baidu.com/rest/v1/search?query=html&pageNum=1&pageSize=10">开发者搜索</a> 获取搜索结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> selectionObj = <span class="built_in">window</span>.getSelection()</span><br><span class="line">      <span class="keyword">var</span> selectedText = selectionObj.toString()</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;selectionObj::&#x27;</span>, selectedText)</span><br><span class="line">      <span class="keyword">if</span> (selectedText.length === <span class="number">0</span>) &#123;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        axios</span><br><span class="line">          .get(</span><br><span class="line">            <span class="string">`https://kaifa.baidu.com/rest/v1/search?query=<span class="subst">$&#123;selectedText&#125;</span>&amp;pageNum=1&amp;pageSize=10`</span></span><br><span class="line">          )</span><br><span class="line">          .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> &#123; data &#125; = res.data.data.documents</span><br><span class="line">            <span class="built_in">console</span>.log(data)</span><br><span class="line">            <span class="keyword">if</span> (data.length) &#123;</span><br><span class="line">              <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                data: data,</span><br><span class="line">                show: <span class="literal">true</span>,</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改 render，展示搜索结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; show, data &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &#123;show ? (</span><br><span class="line">          &lt;div className=<span class="string">&quot;Wokoo&quot;</span>&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">              &#123;data.map(<span class="function">(<span class="params">i</span>) =&gt;</span> (</span><br><span class="line">                &lt;li&gt;&#123;i.title&#125;&lt;/li&gt;</span><br><span class="line">              ))&#125;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        ) : <span class="literal">null</span>&#125;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>此时，网页中能够看到搜索的结果了，基本功能搞定了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7836c1fdf15242f98efe616b11ef3e05~tplv-k3u1fbpfcp-watermark.image"></p>
<p><strong>步骤 3. 计算弹窗出现的位置，让弹窗出现在选中文字下方</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68e92522fb8d45f194915a24c114ad32~tplv-k3u1fbpfcp-watermark.image"><br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e84a26dfb614484b180be34fd49cb7a~tplv-k3u1fbpfcp-watermark.image"></p>
<p>我们可以得出计算公式为：</p>
<blockquote>
<p>left = x + width/2 - MODAL_WIDTH/2</p>
<p>top = y + height</p>
</blockquote>
<p>此时，<code>app.js</code>的代码被改造成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./app.less&#x27;</span></span><br><span class="line"><span class="keyword">const</span> MODAL_WIDTH = <span class="number">350</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">show</span>: <span class="literal">false</span>, <span class="attr">data</span>: [] &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> selectionObj = <span class="built_in">window</span>.getSelection()</span><br><span class="line">      <span class="keyword">var</span> selectedText = selectionObj.toString()</span><br><span class="line">      <span class="keyword">if</span> (selectedText.length === <span class="number">0</span>) &#123;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> selectionObjRect = selectionObj</span><br><span class="line">          .getRangeAt(<span class="number">0</span>)</span><br><span class="line">          .getBoundingClientRect()</span><br><span class="line">        <span class="keyword">let</span> &#123; x, y, height, width &#125; = selectionObjRect <span class="comment">// 获取选中文字的位置，x y是横纵坐标，height width是选中文字的高度和宽度</span></span><br><span class="line">        <span class="comment">// 计算弹窗位置，算出left和top</span></span><br><span class="line">        <span class="keyword">var</span> left = x - MODAL_WIDTH / <span class="number">2</span> + width / <span class="number">2</span></span><br><span class="line">        left = left &gt; <span class="number">10</span> ? left : <span class="number">10</span></span><br><span class="line">        <span class="keyword">var</span> top = y + height</span><br><span class="line">        <span class="keyword">var</span> scrollLeft =</span><br><span class="line">          <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft</span><br><span class="line">        <span class="keyword">var</span> scrollTop =</span><br><span class="line">          <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">        axios</span><br><span class="line">          .get(</span><br><span class="line">            <span class="string">`https://kaifa.baidu.com/rest/v1/search?query=<span class="subst">$&#123;selectedText&#125;</span>&amp;pageNum=1&amp;pageSize=10`</span></span><br><span class="line">          )</span><br><span class="line">          .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> &#123; data &#125; = res.data.data.documents</span><br><span class="line">            <span class="keyword">if</span> (data.length) &#123;</span><br><span class="line">              <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                data,</span><br><span class="line">                show: <span class="literal">true</span>,</span><br><span class="line">                selectedText: selectedText,</span><br><span class="line">                modalPosition: &#123;</span><br><span class="line">                  left: left + scrollLeft,</span><br><span class="line">                  top: top + scrollTop,</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; show, selectedText, modalPosition, data &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &#123;show &amp;&amp; data &amp;&amp; data.length ? (</span><br><span class="line">          &lt;div</span><br><span class="line">            className=<span class="string">&quot;move-search&quot;</span></span><br><span class="line">            id=<span class="string">&quot;MoveSearchApp&quot;</span></span><br><span class="line">            style=&#123;&#123;</span><br><span class="line">              ...modalPosition,</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;move-search-content&quot;</span>&gt;</span><br><span class="line">              &lt;ul className=<span class="string">&quot;move-search-ul&quot;</span>&gt;</span><br><span class="line">                &#123;data.map(<span class="function">(<span class="params">l</span>) =&gt;</span> (</span><br><span class="line">                  &lt;li className=<span class="string">&quot;move-search-li&quot;</span> key=&#123;l.id&#125;&gt;</span><br><span class="line">                    &lt;a href=&#123;l.url&#125; target=<span class="string">&quot;_blank&quot;</span>&gt;</span><br><span class="line">                      &#123;l.title&#125;</span><br><span class="line">                    &lt;/a&gt;</span><br><span class="line">                    &lt;span&gt;&#123;l.summary&#125;&lt;/span&gt;</span><br><span class="line">                  &lt;/li&gt;</span><br><span class="line">                ))&#125;</span><br><span class="line">              &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;move-search-bottom-fade&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;footer className=<span class="string">&quot;move-search-footer&quot;</span>&gt;</span><br><span class="line">              &lt;a</span><br><span class="line">                href=&#123;<span class="string">`https://kaifa.baidu.com/searchPage?wd=<span class="subst">$&#123;selectedText&#125;</span>`</span>&#125;</span><br><span class="line">                target=<span class="string">&quot;_blank&quot;</span></span><br><span class="line">              &gt;</span><br><span class="line">                Read More</span><br><span class="line">              &lt;/a&gt;</span><br><span class="line">            &lt;/footer&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        ) : <span class="literal">null</span>&#125;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别忘了增加样式，修改 app.less</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.move-search</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">350px</span>;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2147483647</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>) <span class="number">0px</span> <span class="number">16px</span> <span class="number">100px</span> <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.1s</span> ease-out <span class="number">0s</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solide <span class="number">#282a33</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: scroll;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤 4. 边界检测，点击弹窗外部，弹窗隐藏</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56e7d842346e496bb864c206da741c9e~tplv-k3u1fbpfcp-watermark.image"></p>
<p>边界检测的判断条件如下：</p>
<blockquote>
<p>left+width &gt; x &gt; left &amp;&amp; top+height &gt; y &gt; top</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boundaryDetection</span>(<span class="params">x, y, modalPosition = &#123; left: <span class="number">0</span>, top: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; left, top &#125; = modalPosition</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    x &gt; left &amp;&amp;</span><br><span class="line">    x &lt; left + MODAL_WIDTH &amp;&amp;</span><br><span class="line">    y &gt; top &amp;&amp;</span><br><span class="line">    y &lt; top + MoveSearchApp.offsetHeight</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>app.js</code>增加弹窗消失的逻辑，在 selectedText 为空时判断鼠标位置是否在弹窗内。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./app.less&#x27;</span></span><br><span class="line"><span class="comment">// 弹窗宽度</span></span><br><span class="line"><span class="keyword">const</span> MODAL_WIDTH = <span class="number">350</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 边界检测，鼠标点击modal之外，modal隐藏</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>x 鼠标的x轴位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>y 鼠标的y轴位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>modalPosition 弹窗的left和top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boundaryDetection</span>(<span class="params">x, y, modalPosition = &#123; left: <span class="number">0</span>, top: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; left, top &#125; = modalPosition</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    x &gt; left &amp;&amp;</span><br><span class="line">    x &lt; left + MODAL_WIDTH &amp;&amp;</span><br><span class="line">    y &gt; top &amp;&amp;</span><br><span class="line">    y &lt; top + MoveSearchApp.offsetHeight</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123; <span class="attr">show</span>: <span class="literal">false</span>, <span class="attr">data</span>: [] &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> selectionObj = <span class="built_in">window</span>.getSelection()</span><br><span class="line">      <span class="keyword">var</span> selectedText = selectionObj.toString()</span><br><span class="line">      <span class="keyword">if</span> (selectedText.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.state.show) &#123;</span><br><span class="line">          <span class="comment">// 重新计算是否关闭弹窗</span></span><br><span class="line">          <span class="comment">// 检测鼠标位置是否在弹窗内，不是则关闭弹窗</span></span><br><span class="line">          <span class="keyword">var</span> inModal = boundaryDetection(</span><br><span class="line">            e.clientX,</span><br><span class="line">            e.clientY,</span><br><span class="line">            <span class="built_in">this</span>.state.modalPosition</span><br><span class="line">          )</span><br><span class="line">          <span class="keyword">if</span> (!inModal) &#123;</span><br><span class="line">            <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">              show: <span class="literal">false</span>,</span><br><span class="line">              data: [],</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> selectionObjRect = selectionObj</span><br><span class="line">          .getRangeAt(<span class="number">0</span>)</span><br><span class="line">          .getBoundingClientRect()</span><br><span class="line">        <span class="keyword">let</span> &#123; x, y, height, width &#125; = selectionObjRect <span class="comment">// 获取选中文字的位置，x y是横纵坐标，height width是选中文字的高度和宽度</span></span><br><span class="line">        <span class="comment">// 计算弹窗位置，算出left和top</span></span><br><span class="line">        <span class="keyword">var</span> left = x - MODAL_WIDTH / <span class="number">2</span> + width / <span class="number">2</span></span><br><span class="line">        left = left &gt; <span class="number">10</span> ? left : <span class="number">10</span></span><br><span class="line">        <span class="keyword">var</span> top = y + height</span><br><span class="line">        <span class="keyword">var</span> scrollLeft =</span><br><span class="line">          <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft</span><br><span class="line">        <span class="keyword">var</span> scrollTop =</span><br><span class="line">          <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">        axios</span><br><span class="line">          .get(</span><br><span class="line">            <span class="string">`https://kaifa.baidu.com/rest/v1/search?query=<span class="subst">$&#123;selectedText&#125;</span>&amp;pageNum=1&amp;pageSize=10`</span></span><br><span class="line">          )</span><br><span class="line">          .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> &#123; data &#125; = res.data.data.documents</span><br><span class="line">            <span class="keyword">if</span> (data.length) &#123;</span><br><span class="line">              <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">                data,</span><br><span class="line">                show: <span class="literal">true</span>,</span><br><span class="line">                selectedText: selectedText,</span><br><span class="line">                modalPosition: &#123;</span><br><span class="line">                  left: left + scrollLeft,</span><br><span class="line">                  top: top + scrollTop,</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; show, selectedText, modalPosition, data &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &#123;show &amp;&amp; data &amp;&amp; data.length ? (</span><br><span class="line">          &lt;div</span><br><span class="line">            className=<span class="string">&quot;move-search&quot;</span></span><br><span class="line">            id=<span class="string">&quot;MoveSearchApp&quot;</span></span><br><span class="line">            style=&#123;&#123;</span><br><span class="line">              ...modalPosition,</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;move-search-content&quot;</span>&gt;</span><br><span class="line">              &lt;ul className=<span class="string">&quot;move-search-ul&quot;</span>&gt;</span><br><span class="line">                &#123;data.map(<span class="function">(<span class="params">l</span>) =&gt;</span> (</span><br><span class="line">                  &lt;li className=<span class="string">&quot;move-search-li&quot;</span> key=&#123;l.id&#125;&gt;</span><br><span class="line">                    &lt;a href=&#123;l.url&#125; target=<span class="string">&quot;_blank&quot;</span>&gt;</span><br><span class="line">                      &#123;l.title&#125;</span><br><span class="line">                    &lt;/a&gt;</span><br><span class="line">                    &lt;span&gt;&#123;l.summary&#125;&lt;/span&gt;</span><br><span class="line">                  &lt;/li&gt;</span><br><span class="line">                ))&#125;</span><br><span class="line">              &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div className=<span class="string">&quot;move-search-bottom-fade&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;footer className=<span class="string">&quot;move-search-footer&quot;</span>&gt;</span><br><span class="line">              &lt;a</span><br><span class="line">                href=&#123;<span class="string">`https://kaifa.baidu.com/searchPage?wd=<span class="subst">$&#123;selectedText&#125;</span>`</span>&#125;</span><br><span class="line">                target=<span class="string">&quot;_blank&quot;</span></span><br><span class="line">              &gt;</span><br><span class="line">                Read More</span><br><span class="line">              &lt;/a&gt;</span><br><span class="line">            &lt;/footer&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        ) : <span class="literal">null</span>&#125;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，项目的基本功能已经开发完成 🎉，一些样式问题可以自行调整。</p>
<p>具体的代码逻辑可看 github 地址：<a href="https://github.com/kinyaying/wokoo/tree/master/example/MoveSearch">MoveSearch</a></p>
<h3 id="1-3-解决跨域问题"><a href="#1-3-解决跨域问题" class="headerlink" title="1.3 解决跨域问题"></a>1.3 解决跨域问题</h3><p>百度的接口不允许跨域访问。也就是说如果我们在一个第三方页面，比如 cdn，掘金等的网页里，要访问百度的接口就存在跨域限制，没法访问。我采用增加 node 中间层，在 node 中给响应增加<code>Access-Control-Allow-Origin</code>请求头的方式开启跨域。</p>
<p>目前有现成的提供 serverless 服务的第三方厂家，提供服务器，node 环境等服务，我们只要关心 node 的代码逻辑即可，部署服务器配置环境等问题交给第三方厂家解决。我采用<a href="https://vercel.com/dashboard">vercel</a>提供的服务。</p>
<p>下面的内容和插件开发关系不大，如果不感兴趣的同学可以直接使用我配置好的域名：<code>https:/movesearch.vercel.app/api/baidu</code>。<br>也就是将代码中 axios 请求的 url 由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;https:&#x2F;&#x2F;kaifa.baidu.com&#x2F;rest&#x2F;v1&#x2F;search?query&#x3D;$&#123;selectedText&#125;&amp;pageNum&#x3D;1&amp;pageSize&#x3D;10&#96;</span><br></pre></td></tr></table></figure>

<p>替换成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;https:&#x2F;&#x2F;movesearch.vercel.app&#x2F;api&#x2F;baidu?query&#x3D;$&#123;selectedText&#125;&amp;pageNum&#x3D;1&amp;pageSize&#x3D;10&#96;</span><br></pre></td></tr></table></figure>

<p>如果对于如何实现跨域配置感兴趣的话，可以继续往下看 👇。</p>
<ol>
<li>登录<a href="https://vercel.com/dashboard">vercel</a>官网，根据提示绑定 github 账号；</li>
<li>点击新建 next 项目。vercel 会自动给你的 github 上创建新的仓库，并有一个初始化项目；（注意：此处会让你填写仓库名，此仓库名和域名是相关联的。）</li>
<li>git clone 此项目到本地，根据 readme 的提示，执行<code>npm run dev</code>，启动项目</li>
<li>增加<code>src/api/baidu.js</code>文件，内容如下：</li>
</ol>
<p>稍微解释一下，<code>src/api/baidu.js</code>下的文件对应的就是<code>/api/baidu</code>接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// restream parsed body before proxying</span></span><br><span class="line"><span class="keyword">var</span> restream = <span class="function"><span class="keyword">function</span> (<span class="params">proxyRes, req, res, options</span>) </span>&#123;</span><br><span class="line">  proxyRes.headers[<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>] = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  proxyRes.headers[<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>] = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  proxyRes.headers[<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>] = <span class="string">&#x27;GET, POST, PUT, OPTIONS&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apiProxy = createProxyMiddleware(&#123;</span><br><span class="line">  target: <span class="string">&#x27;https://kaifa.baidu.com/&#x27;</span>,</span><br><span class="line">  changeOrigin: <span class="literal">true</span>,</span><br><span class="line">  pathRewrite: &#123; <span class="string">&#x27;^/api/baidu&#x27;</span>: <span class="string">&#x27;/rest/v1/search&#x27;</span> &#125;,</span><br><span class="line">  secure: <span class="literal">false</span>,</span><br><span class="line">  onProxyRes: restream,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  apiProxy(req, res, <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;result:&#x27;</span>, result)</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">`Request &#x27;<span class="subst">$&#123;req.url&#125;</span>&#x27; is not proxied! We should never reach here!`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改完成后直接 git push 就行。代码推仓库后会，vercel 会自动拉取最新代码更新到它的服务器，我们只要调用一下接口看是否通就行。<br>具体的代码逻辑可看 github 地址：<a href="https://github.com/kinyaying/nextjs">nextjs</a></p>
<h2 id="二、知乎专栏目录-zhihu-helper"><a href="#二、知乎专栏目录-zhihu-helper" class="headerlink" title="二、知乎专栏目录 zhihu-helper"></a>二、知乎专栏目录 zhihu-helper</h2><h3 id="成品展示-1"><a href="#成品展示-1" class="headerlink" title="成品展示"></a><strong>成品展示</strong></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cafa039c4bbe4edaba88a76715bb38ac~tplv-k3u1fbpfcp-watermark.image"><br>安装地址：</p>
<ol>
<li>安装<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN">油猴插件</a> （如果安装过则不用再安）</li>
<li>安装 <a href="https://greasyfork.org/zh-CN/scripts/421238-zhihu-helper">zhihu-helper</a></li>
</ol>
<p>代码地址：<a href="https://github.com/kinyaying/wokoo/tree/master/example/zhihu-helper">wokoo/zhihu-helper</a></p>
<h3 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a><strong>开发步骤</strong></h3><h4 id="1-1-项目安装-amp-初始化配置-1"><a href="#1-1-项目安装-amp-初始化配置-1" class="headerlink" title="1.1 项目安装 &amp; 初始化配置"></a>1.1 项目安装 &amp; 初始化配置</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i wokoo -g</span><br><span class="line">wokoo zhihu-help</span><br></pre></td></tr></table></figure>

<p>选择模板</p>
<ul>
<li><input disabled="" type="checkbox"> vue</li>
<li><input disabled="" type="checkbox"> react</li>
</ul>
<p>这里选择 react，等待项目安装。项目安装完成后，根据提示执行下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd zhihu-helper</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<ul>
<li><p>打开油猴脚本编辑器，把 tampermonkey.js 的内容复制进去。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c9ead8b41c84e54b0d6bf056da19cc8~tplv-k3u1fbpfcp-zoom-1.image" alt="tampermonkey"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9037cc204ab434786c2b0e7ddde8541~tplv-k3u1fbpfcp-zoom-1.image" alt="copy-tampermonkey"></p>
</li>
<li><p>打开网页<a href="https://zhuanlan.zhihu.com/mandy">知乎专栏</a>，右上角出现一只猴子图标，说明项目已跑通。</p>
</li>
</ul>
<p><strong>补充说明</strong></p>
<p>此处有的浏览器不会出现猴子图标。打开控制台可见报错：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c6afc5b4cb4494b72c0d7b685f5579~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>再看请求的 html 资源的响应头，可以发现多了一条<code>content-security-policy</code>规则。也就是说知乎使用了 csp 内容安全策略，通过<code>content-security-policy</code>中的<code>script-src</code>字段可知，知乎只允许加载指定域名的 js。具体情况可阅读 👉 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">内容安全策略( CSP )</a></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7ce3b03a5434e2aac0a911940d01a0d~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><strong>如何绕过此安全策略，此处给两个方法：</strong></p>
<ol>
<li>安装插件<a href="https://chrome.pictureknow.com/extension?id=5b80153e8db143afa59310bc0f282f1f">Disable Content-Security-Policy</a>, 在调试知乎页面时开启插件，自动把 html 页面的<code>content-security-policy</code>给设置为空。<br>注意，开启页面后，要点一下插件，按钮变成彩色了才算开启成功<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12886ea968314e57a5fdb99db26c4eb9~tplv-k3u1fbpfcp-watermark.image"></li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba9ac0c0e6d14367bcd51b3aff3a9e2b~tplv-k3u1fbpfcp-zoom-1.image"></p>
<ol start="2">
<li><p>会配置 charles 的同学，可以设置一条转发规则</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e34719c066b147bbaabe2d19177a8bfe~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78488c8cc8d34cfa93453757f1e75d50~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/190b44584a6c449e84b6463022bafb41~tplv-k3u1fbpfcp-zoom-1.image"></p>
</li>
</ol>
<p>这两种方法选一种就行。</p>
<p>遇到这中 csp 内容安全策略的网页，在上线到油猴商店的时候不能用托管 cdn 的方式，要将代码复制到编辑框中。</p>
<h4 id="1-2-开发基本功能"><a href="#1-2-开发基本功能" class="headerlink" title="1.2 开发基本功能"></a>1.2 开发基本功能</h4><p>整理思路</p>
<ol>
<li>绘制左侧抽屉弹窗</li>
<li>弹窗弹出时请求知乎列表接口，拿到列表数据</li>
<li>下拉时实现加载更多的功能</li>
</ol>
<p>下面我们来逐步实现吧~</p>
<p><strong>步骤 1. 绘制左侧抽屉弹窗</strong></p>
<p>主要通过 this.state.show 控制弹窗的显示隐藏。此步骤挺简单的，可以直接看代码:<a href="https://github.com/kinyaying/wokoo/blob/master/example/zhihu-helper/src/step1.js">step1</a>，可以将 index.js 入口里的 app 替换成 step1 查看效果。</p>
<p><strong>步骤 2. 请求<a href="https://www.zhihu.com/api/v4/columns">知乎列表</a>接口，获取列表数据</strong></p>
<ul>
<li>安装 axios，并引入</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure>

<ul>
<li>计算请求参数</li>
</ul>
<p>分析请求的 url 可知，请求接口为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="string">`https://www.zhihu.com/api/v4/columns<span class="subst">$&#123;<span class="built_in">this</span>.queryName&#125;</span>/items?limit=20&amp;offset=<span class="subst">$&#123;offset&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<p>其中 this.queryName 是专栏名称，当页面为<a href="https://zhuanlan.zhihu.com/mandy">专栏列表页</a>时就是 pathname; 当页面为<a href="https://zhuanlan.zhihu.com/p/348005704">专栏详情页</a>时，需要通过类名为<code>ColumnPageHeader-TitleColumn</code>的 a 标签的 href 来获取。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e6ede0ef02494e9ecf138b5ab19c3b~tplv-k3u1fbpfcp-zoom-1.image" alt="zhihu"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec4215a91a3b4bb7a1666f06341c094d~tplv-k3u1fbpfcp-zoom-1.image" alt="zhihu1"></p>
<p>通过这两张图应该更好理解 getQueryName 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getQueryName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> pathname = location.pathname</span><br><span class="line">  <span class="keyword">let</span> detailRegExp = <span class="regexp">/^\/p\/\d+/</span></span><br><span class="line">  <span class="keyword">let</span> queryName = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">// 专栏详情页</span></span><br><span class="line">  <span class="keyword">if</span> (detailRegExp.test(pathname)) &#123;</span><br><span class="line">    <span class="keyword">let</span> aTage = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;ColumnPageHeader-TitleColumn&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> url = aTage[<span class="number">0</span>].href</span><br><span class="line">    queryName = url.slice(url.lastIndexOf(<span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 专栏列表页</span></span><br><span class="line">    <span class="comment">// http://zhuanlan.zhihu和http://zhihu/column两种情况都是专栏</span></span><br><span class="line">    <span class="keyword">if</span> (pathname.indexOf(<span class="string">&#x27;/column&#x27;</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">      pathname = pathname.slice(<span class="string">&#x27;/column&#x27;</span>.length)</span><br><span class="line">    &#125;</span><br><span class="line">    queryName = pathname</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.queryName = queryName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而列表页又存在两种域名：<a href="https://www.zhihu.com/column/mandy">https://www.zhihu.com/column/mandy</a> 和 <a href="https://zhuanlan.zhihu.com/mandy">https://zhuanlan.zhihu.com/mandy</a> 所以在<code>else</code>逻辑里针对<code>https://www.zhihu.com/column/mandy </code>做了处理，只保留/mandy</p>
<p>通过 getQueryName 方法，我们获取到了请求参数</p>
<ul>
<li>发送请求，拉取目录列表</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getList = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.state.hasMore) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">let</span> &#123; offset &#125; = <span class="built_in">this</span>.state</span><br><span class="line">  <span class="keyword">let</span> &#123; data &#125; = <span class="keyword">await</span> axios.get(</span><br><span class="line">    <span class="string">`https://www.zhihu.com/api/v4/columns<span class="subst">$&#123;<span class="built_in">this</span>.queryName&#125;</span>/items?limit=20&amp;offset=<span class="subst">$&#123;offset&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">let</span> list = data.data.map(<span class="function">(<span class="params">i</span>) =&gt;</span> (&#123;</span><br><span class="line">    title: i.title,</span><br><span class="line">    url: i.url,</span><br><span class="line">    id: i.id,</span><br><span class="line">    commentCount: i.comment_count,</span><br><span class="line">    voteupCount: i.voteup_count,</span><br><span class="line">  &#125;))</span><br><span class="line">  <span class="keyword">if</span> (data.paging.is_end) &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">hasMore</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  offset += limit</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    list: [...this.state.list, ...list],</span><br><span class="line">    offset,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步的过程实现完了，代码在这里 👉<a href="https://github.com/kinyaying/wokoo/blob/master/example/zhihu-helper/src/step2.js">step2</a> ，可以将 index.js 入口里的 app 替换成 step2 查看效果。</p>
<p>这时插件的效果是这样的，除了没有下拉加载功能，其他基本完工了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3417e0182fd94ea5b4b15159b0f9768c~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210206004837608"></p>
<p><strong>步骤 3. 下拉时实现加载更多的功能</strong></p>
<p>无限滚动的组件引了第三方库<a href="https://www.npmjs.com/package/react-infinite-scroll-component">react-infinite-scroll-component</a>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install react-infinite-scroll-component</span><br></pre></td></tr></table></figure>

<p>主要是在 render 函数里增加 InfiniteScroll 组件，注意 InfiniteScroll 的 height 需要通过计算给一个固定的值，否则无法触发滚动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul className=<span class="string">&quot;list-ul&quot;</span> onMouseLeave=&#123;<span class="built_in">this</span>.handleMouseLeave&#125;&gt;</span><br><span class="line">  &lt;InfiniteScroll</span><br><span class="line">    dataLength=&#123;list.length&#125;</span><br><span class="line">    next=&#123;<span class="built_in">this</span>.handleInfiniteOnLoad&#125;</span><br><span class="line">    hasMore=&#123;hasMore&#125;</span><br><span class="line">    loader=&#123;<span class="xml"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span>&#125;</span><br><span class="line">    height=&#123;<span class="built_in">document</span>.documentElement.clientHeight - <span class="number">53</span>&#125;</span><br><span class="line">    endMessage=&#123;</span><br><span class="line">      &lt;p style=&#123;&#123; <span class="attr">textAlign</span>: <span class="string">&#x27;center&#x27;</span> &#125;&#125;&gt;</span><br><span class="line">        &lt;b&gt;到底了，没内容啦~&lt;/b&gt;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;list.map(<span class="function">(<span class="params">i</span>) =&gt;</span> (</span><br><span class="line">      &lt;li className=<span class="string">&quot;list-li&quot;</span> key=&#123;i.id&#125;&gt;</span><br><span class="line">        ...</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">  &lt;/InfiniteScroll&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>此时功能已经开发完成，具体代码查看 👉<a href="https://github.com/kinyaying/wokoo/blob/master/example/zhihu-helper/src/app.js">app.js</a></p>
<h3 id="部署插件到油猴商店"><a href="#部署插件到油猴商店" class="headerlink" title="部署插件到油猴商店"></a>部署插件到油猴商店</h3><p><strong>3.1 构建</strong></p>
<p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p><strong>3.2 确认油猴脚本文件 tampermonkey.js</strong></p>
<p>此文件中被注释掉的//@xxx 都有含义，可以对应着 <a href="https://www.tampermonkey.net/documentation.php?version=4.6&ext=dhdg">tampermonkey 开发文档 </a> 理解。</p>
<ul>
<li><p>@description 插件描述</p>
</li>
<li><p>@match 指定某些域名下开启此插件，默认配了两条，<code>// @match https://*/*</code>和<code>// @match https://*/*</code>表示在所有域名下都开启。但是此处希望只在 zhihu 专栏里使用此插件，所以要修改@math 字段。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @match        https://zhuanlan.zhihu.com/*</span></span><br><span class="line"><span class="comment">// @match        https://www.zhihu.com/column/*</span></span><br></pre></td></tr></table></figure></li>
<li><p>@require 油猴脚本内部帮忙引入第三方资源，比如 jquery，react 等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @require https://unpkg.com/react@17/umd/react.production.min.js</span></span><br><span class="line"><span class="comment">// @require https://unpkg.com/react-dom@17/umd/react-dom.production.min.js</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3.3 发布插件到油猴市场</strong></p>
<p>发布油猴市场的优点是不用审核，即发即用，非常方便。</p>
<ol>
<li>将/dist/app.bundle.js 文件部署到 cdn 上，获取到对应 url。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li><p>js 文件可放到 github 上，如果托管到 github 上最好做 cdn 加速（我使用 cdn.jsdelivr.net 进行 cdn 加速）。</p>
</li>
<li><p>如果没有 cdn 服务器可跳过此步骤，在步骤 4 直接将 app.bundle.js 复制到油猴脚本编辑器中</p>
</li>
</ul>
<ol start="2">
<li><p>登录<a href="https://greasyfork.org/">油猴市场</a>，谷歌账号或 github 账号都可使用。</p>
</li>
<li><p>点击账号名称，再点击「发布你编写的脚本」</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd3a083d7d9246aaaeddbe3bf1806698~tplv-k3u1fbpfcp-zoom-1.image" alt="wokoo-tamp3"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1706095c2793482bbd4e822ff9b0ed5d~tplv-k3u1fbpfcp-zoom-1.image" alt="wokoo-tamp4"></p>
</li>
<li><p>进入编辑页，将 tampermonkey.js 里的内容复制到编辑框中</p>
<p>注意：</p>
<ul>
<li><p>步骤 1 中如果托管了 cdn，需要将代码中的<code>localhost:8080</code>网址替换成静态资源 url</p>
</li>
<li><p>步骤 1 中没有托管 cdn，不能直接将/dist/app.bundle.js 文件里的内容复制编辑框。因为编辑框内代码有最大限制，我们构建的 app.bundle.js 把 react 等三方库构建进去超过最大限制了。</p>
<p>需要对构建结果进行拆包</p>
<p>4.1 修改 tampermonkey.js ，通过@require 方式引入 react 和 react-dom</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         zhihu-helper</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.0.1</span></span><br><span class="line"><span class="comment">// @description  知乎目录</span></span><br><span class="line"><span class="comment">// @author       xx</span></span><br><span class="line"><span class="comment">// @match        https://zhuanlan.zhihu.com/*</span></span><br><span class="line"><span class="comment">// @match        https://www.zhihu.com/column/*</span></span><br><span class="line"><span class="comment">// @require https://unpkg.com/react@17/umd/react.production.min.js</span></span><br><span class="line"><span class="comment">// @require https://unpkg.com/react-dom@17/umd/react-dom.production.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.bundle.js构建好的代码</span></span><br></pre></td></tr></table></figure>

<p>4.2 修改 webpack.config.base.js 的 entry 字段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    app: <span class="string">&#x27;/src/index.js&#x27;</span>,</span><br><span class="line">    vendor: [</span><br><span class="line">      <span class="comment">// 将react和react-dom这些单独打包出来，减小打包文件体积</span></span><br><span class="line">      <span class="string">&#x27;react&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;react-dom&#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>4.3 重新执行<code>npm run build</code> 构建出新的 app.bundle.js，复制到油猴市场的编辑框内。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2da6218f824bc7917a43b107362899~tplv-k3u1fbpfcp-zoom-1.image" alt="zhihu-tampermonkey"></p>
</li>
</ul>
</li>
<li><p>点击 「发布脚本」即可</p>
</li>
</ol>
<h1 id="wokoo-脚手架的搭建"><a href="#wokoo-脚手架的搭建" class="headerlink" title="wokoo 脚手架的搭建"></a>wokoo 脚手架的搭建</h1><p>感兴趣的同学可以阅读 <a href="https://gitee.com/zhufengpeixun/browser-plugin/blob/master/wokoo%E8%84%9A%E6%89%8B%E6%9E%B6(%E6%90%AD%E5%BB%BA%E7%AF%87).md">wokoo 脚手架（搭建篇）</a></p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
</search>
